// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "types.proto" (package "types", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Primitive } from "./schema";
import { Struct } from "./schema";
/**
 * @generated from protobuf message types.World
 */
export interface World {
    /**
     * The hex-encoded address of the world.
     *
     * @generated from protobuf field: string world_address = 1
     */
    world_address: string;
    /**
     * A list of metadata for all registered components in the world.
     *
     * @generated from protobuf field: repeated types.Model models = 2
     */
    models: Model[];
}
/**
 * @generated from protobuf message types.Model
 */
export interface Model {
    /**
     * Model selector
     *
     * @generated from protobuf field: bytes selector = 1
     */
    selector: Uint8Array;
    /**
     * Model namespace
     *
     * @generated from protobuf field: string namespace = 2
     */
    namespace: string;
    /**
     * Model name
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * Model size when it is packed for storage
     *
     * @generated from protobuf field: uint32 packed_size = 4
     */
    packed_size: number;
    /**
     * Model size when it is unpacked
     *
     * @generated from protobuf field: uint32 unpacked_size = 5
     */
    unpacked_size: number;
    /**
     * felt bytes of the class hash of the component
     *
     * @generated from protobuf field: bytes class_hash = 6
     */
    class_hash: Uint8Array;
    /**
     * The layout of the component in bytes
     *
     * @generated from protobuf field: bytes layout = 7
     */
    layout: Uint8Array;
    /**
     * The schema of the component serialized in bytes (for simplicity sake)
     *
     * @generated from protobuf field: bytes schema = 8
     */
    schema: Uint8Array;
    /**
     * felt bytes of the contract address of the component
     *
     * @generated from protobuf field: bytes contract_address = 9
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: bool use_legacy_store = 10
     */
    use_legacy_store: boolean;
}
/**
 * @generated from protobuf message types.Entity
 */
export interface Entity {
    /**
     * The entity's hashed keys
     *
     * @generated from protobuf field: bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array;
    /**
     * Models of the entity
     *
     * @generated from protobuf field: repeated types.Struct models = 2
     */
    models: Struct[];
    /**
     * Created at timestamp
     *
     * @generated from protobuf field: uint64 created_at = 3
     */
    created_at: bigint;
    /**
     * Updated at timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 4
     */
    updated_at: bigint;
    /**
     * Block timestamp when the entity was updated
     *
     * @generated from protobuf field: uint64 executed_at = 5
     */
    executed_at: bigint;
}
/**
 * @generated from protobuf message types.Event
 */
export interface Event {
    /**
     * The event's keys
     *
     * @generated from protobuf field: repeated bytes keys = 1
     */
    keys: Uint8Array[];
    /**
     * Data of the event
     *
     * @generated from protobuf field: repeated bytes data = 2
     */
    data: Uint8Array[];
    /**
     * event's transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 3
     */
    transaction_hash: Uint8Array;
}
/**
 * @generated from protobuf message types.Query
 */
export interface Query {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
    /**
     * @generated from protobuf field: bool no_hashed_keys = 2
     */
    no_hashed_keys: boolean;
    /**
     * @generated from protobuf field: repeated string models = 3
     */
    models: string[];
    /**
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
    /**
     * @generated from protobuf field: bool historical = 5
     */
    historical: boolean;
}
/**
 * @generated from protobuf message types.EventQuery
 */
export interface EventQuery {
    /**
     * @generated from protobuf field: types.KeysClause keys = 1
     */
    keys?: KeysClause;
    /**
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message types.Clause
 */
export interface Clause {
    /**
     * @generated from protobuf oneof: clause_type
     */
    clause_type: {
        oneofKind: "hashed_keys";
        /**
         * @generated from protobuf field: types.HashedKeysClause hashed_keys = 1
         */
        hashed_keys: HashedKeysClause;
    } | {
        oneofKind: "keys";
        /**
         * @generated from protobuf field: types.KeysClause keys = 2
         */
        keys: KeysClause;
    } | {
        oneofKind: "member";
        /**
         * @generated from protobuf field: types.MemberClause member = 3
         */
        member: MemberClause;
    } | {
        oneofKind: "composite";
        /**
         * @generated from protobuf field: types.CompositeClause composite = 4
         */
        composite: CompositeClause;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message types.KeysClause
 */
export interface KeysClause {
    /**
     * @generated from protobuf field: repeated bytes keys = 2
     */
    keys: Uint8Array[];
    /**
     * @generated from protobuf field: types.PatternMatching pattern_matching = 3
     */
    pattern_matching: PatternMatching;
    /**
     * @generated from protobuf field: repeated string models = 4
     */
    models: string[];
}
/**
 * @generated from protobuf message types.HashedKeysClause
 */
export interface HashedKeysClause {
    /**
     * @generated from protobuf field: repeated bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array[];
}
/**
 * @generated from protobuf message types.MemberValue
 */
export interface MemberValue {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 1
         */
        primitive: Primitive;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 2
         */
        string: string;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: types.MemberValueList list = 3
         */
        list: MemberValueList;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message types.MemberValueList
 */
export interface MemberValueList {
    /**
     * @generated from protobuf field: repeated types.MemberValue values = 1
     */
    values: MemberValue[];
}
/**
 * @generated from protobuf message types.MemberClause
 */
export interface MemberClause {
    /**
     * @generated from protobuf field: string model = 2
     */
    model: string;
    /**
     * @generated from protobuf field: string member = 3
     */
    member: string;
    /**
     * @generated from protobuf field: types.ComparisonOperator operator = 4
     */
    operator: ComparisonOperator;
    /**
     * @generated from protobuf field: types.MemberValue value = 5
     */
    value?: MemberValue;
}
/**
 * @generated from protobuf message types.CompositeClause
 */
export interface CompositeClause {
    /**
     * @generated from protobuf field: types.LogicalOperator operator = 3
     */
    operator: LogicalOperator;
    /**
     * @generated from protobuf field: repeated types.Clause clauses = 4
     */
    clauses: Clause[];
}
/**
 * @generated from protobuf message types.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: optional bytes token_id = 1
     */
    token_id?: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
}
/**
 * @generated from protobuf message types.TokenCollection
 */
export interface TokenCollection {
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: uint32 count = 6
     */
    count: number;
    /**
     * @generated from protobuf field: bytes metadata = 7
     */
    metadata: Uint8Array;
}
/**
 * @generated from protobuf message types.TokenBalance
 */
export interface TokenBalance {
    /**
     * @generated from protobuf field: bytes balance = 1
     */
    balance: Uint8Array;
    /**
     * @generated from protobuf field: bytes account_address = 2
     */
    account_address: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 3
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes token_id = 4
     */
    token_id?: Uint8Array;
}
/**
 * @generated from protobuf message types.OrderBy
 */
export interface OrderBy {
    /**
     * @generated from protobuf field: string field = 1
     */
    field: string;
    /**
     * @generated from protobuf field: types.OrderDirection direction = 2
     */
    direction: OrderDirection;
}
/**
 * @generated from protobuf message types.Controller
 */
export interface Controller {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: uint64 deployed_at_timestamp = 3
     */
    deployed_at_timestamp: bigint;
}
/**
 * @generated from protobuf message types.Pagination
 */
export interface Pagination {
    /**
     * @generated from protobuf field: string cursor = 1
     */
    cursor: string;
    /**
     * @generated from protobuf field: uint32 limit = 2
     */
    limit: number;
    /**
     * @generated from protobuf field: types.PaginationDirection direction = 3
     */
    direction: PaginationDirection;
    /**
     * @generated from protobuf field: repeated types.OrderBy order_by = 4
     */
    order_by: OrderBy[];
}
/**
 * @generated from protobuf message types.ControllerQuery
 */
export interface ControllerQuery {
    /**
     * The list of contract addresses to retrieve controllers for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of usernames to retrieve controllers for
     *
     * @generated from protobuf field: repeated string usernames = 2
     */
    usernames: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message types.TokenQuery
 */
export interface TokenQuery {
    /**
     * The list of contract addresses to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message types.TokenBalanceQuery
 */
export interface TokenBalanceQuery {
    /**
     * The account addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message types.TransactionCall
 */
export interface TransactionCall {
    /**
     * The contract address being called
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The function name being called
     *
     * @generated from protobuf field: string entrypoint = 2
     */
    entrypoint: string;
    /**
     * The calldata for the function call
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)
     *
     * @generated from protobuf field: types.CallType call_type = 4
     */
    call_type: CallType;
    /**
     * The address making the call
     *
     * @generated from protobuf field: bytes caller_address = 5
     */
    caller_address: Uint8Array;
}
/**
 * @generated from protobuf message types.Transaction
 */
export interface Transaction {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 1
     */
    transaction_hash: Uint8Array;
    /**
     * The sender address
     *
     * @generated from protobuf field: bytes sender_address = 2
     */
    sender_address: Uint8Array;
    /**
     * The transaction calldata
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The maximum fee for the transaction
     *
     * @generated from protobuf field: bytes max_fee = 4
     */
    max_fee: Uint8Array;
    /**
     * The transaction signature
     *
     * @generated from protobuf field: repeated bytes signature = 5
     */
    signature: Uint8Array[];
    /**
     * The transaction nonce
     *
     * @generated from protobuf field: bytes nonce = 6
     */
    nonce: Uint8Array;
    /**
     * The block number the transaction was included in
     *
     * @generated from protobuf field: uint64 block_number = 7
     */
    block_number: bigint;
    /**
     * The transaction type (INVOKE, L1_HANDLER, etc.)
     *
     * @generated from protobuf field: string transaction_type = 8
     */
    transaction_type: string;
    /**
     * The timestamp when the transaction was executed
     *
     * @generated from protobuf field: uint64 block_timestamp = 9
     */
    block_timestamp: bigint;
    /**
     * The parsed calls within the transaction
     *
     * @generated from protobuf field: repeated types.TransactionCall calls = 10
     */
    calls: TransactionCall[];
    /**
     * The unique models associated with this transaction
     *
     * @generated from protobuf field: repeated bytes unique_models = 11
     */
    unique_models: Uint8Array[];
}
/**
 * @generated from protobuf message types.TransactionFilter
 */
export interface TransactionFilter {
    /**
     * The list of transaction hashes to retrieve
     *
     * @generated from protobuf field: repeated bytes transaction_hashes = 1
     */
    transaction_hashes: Uint8Array[];
    /**
     * The list of caller addresses to filter by
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 2
     */
    caller_addresses: Uint8Array[];
    /**
     * The list of contract addresses to filter by (calls made to these contracts)
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 3
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of entrypoints to filter by
     *
     * @generated from protobuf field: repeated string entrypoints = 4
     */
    entrypoints: string[];
    /**
     * The list of model selectors to filter by
     *
     * @generated from protobuf field: repeated bytes model_selectors = 5
     */
    model_selectors: Uint8Array[];
    /**
     * The block number range to filter by
     *
     * @generated from protobuf field: optional uint64 from_block = 6
     */
    from_block?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_block = 7
     */
    to_block?: bigint;
}
/**
 * @generated from protobuf message types.TransactionQuery
 */
export interface TransactionQuery {
    /**
     * The filter to apply to the query
     *
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message types.Contract
 */
export interface Contract {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType;
    /**
     * Current block height
     *
     * @generated from protobuf field: optional uint64 head = 3
     */
    head?: bigint;
    /**
     * Transactions per second
     *
     * @generated from protobuf field: optional uint64 tps = 4
     */
    tps?: bigint;
    /**
     * Last block timestamp
     *
     * @generated from protobuf field: optional uint64 last_block_timestamp = 5
     */
    last_block_timestamp?: bigint;
    /**
     * Last pending block transaction
     *
     * @generated from protobuf field: optional bytes last_pending_block_tx = 6
     */
    last_pending_block_tx?: Uint8Array;
    /**
     * When the contract was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
    /**
     * When the contract was first tracked
     *
     * @generated from protobuf field: uint64 created_at = 8
     */
    created_at: bigint;
}
/**
 * A request to retrieve contracts
 *
 * @generated from protobuf message types.ContractQuery
 */
export interface ContractQuery {
    /**
     * The list of contract addresses to retrieve
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType[];
}
/**
 * @generated from protobuf enum types.PatternMatching
 */
export enum PatternMatching {
    /**
     * @generated from protobuf enum value: FixedLen = 0;
     */
    FixedLen = 0,
    /**
     * @generated from protobuf enum value: VariableLen = 1;
     */
    VariableLen = 1
}
/**
 * @generated from protobuf enum types.LogicalOperator
 */
export enum LogicalOperator {
    /**
     * @generated from protobuf enum value: AND = 0;
     */
    AND = 0,
    /**
     * @generated from protobuf enum value: OR = 1;
     */
    OR = 1
}
/**
 * @generated from protobuf enum types.ComparisonOperator
 */
export enum ComparisonOperator {
    /**
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * @generated from protobuf enum value: NEQ = 1;
     */
    NEQ = 1,
    /**
     * @generated from protobuf enum value: GT = 2;
     */
    GT = 2,
    /**
     * @generated from protobuf enum value: GTE = 3;
     */
    GTE = 3,
    /**
     * @generated from protobuf enum value: LT = 4;
     */
    LT = 4,
    /**
     * @generated from protobuf enum value: LTE = 5;
     */
    LTE = 5,
    /**
     * @generated from protobuf enum value: IN = 6;
     */
    IN = 6,
    /**
     * @generated from protobuf enum value: NOT_IN = 7;
     */
    NOT_IN = 7,
    /**
     * Array-specific operators
     *
     * Array contains value
     *
     * @generated from protobuf enum value: CONTAINS = 8;
     */
    CONTAINS = 8,
    /**
     * Array contains all values
     *
     * @generated from protobuf enum value: CONTAINS_ALL = 9;
     */
    CONTAINS_ALL = 9,
    /**
     * Array contains any of the values
     *
     * @generated from protobuf enum value: CONTAINS_ANY = 10;
     */
    CONTAINS_ANY = 10,
    /**
     * Array length equals
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_EQ = 11;
     */
    ARRAY_LENGTH_EQ = 11,
    /**
     * Array length greater than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_GT = 12;
     */
    ARRAY_LENGTH_GT = 12,
    /**
     * Array length less than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_LT = 13;
     */
    ARRAY_LENGTH_LT = 13
}
/**
 * @generated from protobuf enum types.OrderDirection
 */
export enum OrderDirection {
    /**
     * @generated from protobuf enum value: ASC = 0;
     */
    ASC = 0,
    /**
     * @generated from protobuf enum value: DESC = 1;
     */
    DESC = 1
}
/**
 * @generated from protobuf enum types.PaginationDirection
 */
export enum PaginationDirection {
    /**
     * @generated from protobuf enum value: FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: BACKWARD = 1;
     */
    BACKWARD = 1
}
/**
 * @generated from protobuf enum types.CallType
 */
export enum CallType {
    /**
     * @generated from protobuf enum value: EXECUTE = 0;
     */
    EXECUTE = 0,
    /**
     * @generated from protobuf enum value: EXECUTE_FROM_OUTSIDE = 1;
     */
    EXECUTE_FROM_OUTSIDE = 1
}
/**
 * @generated from protobuf enum types.ContractType
 */
export enum ContractType {
    /**
     * @generated from protobuf enum value: WORLD = 0;
     */
    WORLD = 0,
    /**
     * @generated from protobuf enum value: ERC20 = 1;
     */
    ERC20 = 1,
    /**
     * @generated from protobuf enum value: ERC721 = 2;
     */
    ERC721 = 2,
    /**
     * @generated from protobuf enum value: ERC1155 = 3;
     */
    ERC1155 = 3,
    /**
     * @generated from protobuf enum value: UDC = 4;
     */
    UDC = 4,
    /**
     * @generated from protobuf enum value: OTHER = 5;
     */
    OTHER = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class World$Type extends MessageType<World> {
    constructor() {
        super("types.World", [
            { no: 1, name: "world_address", kind: "scalar", localName: "world_address", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Model }
        ]);
    }
    create(value?: PartialMessage<World>): World {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_address = "";
        message.models = [];
        if (value !== undefined)
            reflectionMergePartial<World>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: World): World {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string world_address */ 1:
                    message.world_address = reader.string();
                    break;
                case /* repeated types.Model models */ 2:
                    message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: World, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string world_address = 1; */
        if (message.world_address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.world_address);
        /* repeated types.Model models = 2; */
        for (let i = 0; i < message.models.length; i++)
            Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.World
 */
export const World = new World$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Model$Type extends MessageType<Model> {
    constructor() {
        super("types.Model", [
            { no: 1, name: "selector", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "packed_size", kind: "scalar", localName: "packed_size", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "unpacked_size", kind: "scalar", localName: "unpacked_size", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "class_hash", kind: "scalar", localName: "class_hash", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "layout", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "use_legacy_store", kind: "scalar", localName: "use_legacy_store", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Model>): Model {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.selector = new Uint8Array(0);
        message.namespace = "";
        message.name = "";
        message.packed_size = 0;
        message.unpacked_size = 0;
        message.class_hash = new Uint8Array(0);
        message.layout = new Uint8Array(0);
        message.schema = new Uint8Array(0);
        message.contract_address = new Uint8Array(0);
        message.use_legacy_store = false;
        if (value !== undefined)
            reflectionMergePartial<Model>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model): Model {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes selector */ 1:
                    message.selector = reader.bytes();
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* uint32 packed_size */ 4:
                    message.packed_size = reader.uint32();
                    break;
                case /* uint32 unpacked_size */ 5:
                    message.unpacked_size = reader.uint32();
                    break;
                case /* bytes class_hash */ 6:
                    message.class_hash = reader.bytes();
                    break;
                case /* bytes layout */ 7:
                    message.layout = reader.bytes();
                    break;
                case /* bytes schema */ 8:
                    message.schema = reader.bytes();
                    break;
                case /* bytes contract_address */ 9:
                    message.contract_address = reader.bytes();
                    break;
                case /* bool use_legacy_store */ 10:
                    message.use_legacy_store = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Model, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes selector = 1; */
        if (message.selector.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.selector);
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* uint32 packed_size = 4; */
        if (message.packed_size !== 0)
            writer.tag(4, WireType.Varint).uint32(message.packed_size);
        /* uint32 unpacked_size = 5; */
        if (message.unpacked_size !== 0)
            writer.tag(5, WireType.Varint).uint32(message.unpacked_size);
        /* bytes class_hash = 6; */
        if (message.class_hash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.class_hash);
        /* bytes layout = 7; */
        if (message.layout.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.layout);
        /* bytes schema = 8; */
        if (message.schema.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.schema);
        /* bytes contract_address = 9; */
        if (message.contract_address.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.contract_address);
        /* bool use_legacy_store = 10; */
        if (message.use_legacy_store !== false)
            writer.tag(10, WireType.Varint).bool(message.use_legacy_store);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Model
 */
export const Model = new Model$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("types.Entity", [
            { no: 1, name: "hashed_keys", kind: "scalar", localName: "hashed_keys", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Struct },
            { no: 3, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "executed_at", kind: "scalar", localName: "executed_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashed_keys = new Uint8Array(0);
        message.models = [];
        message.created_at = 0n;
        message.updated_at = 0n;
        message.executed_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hashed_keys */ 1:
                    message.hashed_keys = reader.bytes();
                    break;
                case /* repeated types.Struct models */ 2:
                    message.models.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 created_at */ 3:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 4:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 executed_at */ 5:
                    message.executed_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hashed_keys = 1; */
        if (message.hashed_keys.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys);
        /* repeated types.Struct models = 2; */
        for (let i = 0; i < message.models.length; i++)
            Struct.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 3; */
        if (message.created_at !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 4; */
        if (message.updated_at !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.updated_at);
        /* uint64 executed_at = 5; */
        if (message.executed_at !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.executed_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("types.Event", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "transaction_hash", kind: "scalar", localName: "transaction_hash", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.data = [];
        message.transaction_hash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes keys */ 1:
                    message.keys.push(reader.bytes());
                    break;
                case /* repeated bytes data */ 2:
                    message.data.push(reader.bytes());
                    break;
                case /* bytes transaction_hash */ 3:
                    message.transaction_hash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keys[i]);
        /* repeated bytes data = 2; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data[i]);
        /* bytes transaction_hash = 3; */
        if (message.transaction_hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.transaction_hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query$Type extends MessageType<Query> {
    constructor() {
        super("types.Query", [
            { no: 1, name: "clause", kind: "message", T: () => Clause },
            { no: 2, name: "no_hashed_keys", kind: "scalar", localName: "no_hashed_keys", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "models", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination },
            { no: 5, name: "historical", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Query>): Query {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.no_hashed_keys = false;
        message.models = [];
        message.historical = false;
        if (value !== undefined)
            reflectionMergePartial<Query>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query): Query {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                case /* bool no_hashed_keys */ 2:
                    message.no_hashed_keys = reader.bool();
                    break;
                case /* repeated string models */ 3:
                    message.models.push(reader.string());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* bool historical */ 5:
                    message.historical = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool no_hashed_keys = 2; */
        if (message.no_hashed_keys !== false)
            writer.tag(2, WireType.Varint).bool(message.no_hashed_keys);
        /* repeated string models = 3; */
        for (let i = 0; i < message.models.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.models[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool historical = 5; */
        if (message.historical !== false)
            writer.tag(5, WireType.Varint).bool(message.historical);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Query
 */
export const Query = new Query$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventQuery$Type extends MessageType<EventQuery> {
    constructor() {
        super("types.EventQuery", [
            { no: 1, name: "keys", kind: "message", T: () => KeysClause },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<EventQuery>): EventQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQuery): EventQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.KeysClause keys */ 1:
                    message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);
                    break;
                case /* types.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.KeysClause keys = 1; */
        if (message.keys)
            KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.EventQuery
 */
export const EventQuery = new EventQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Clause$Type extends MessageType<Clause> {
    constructor() {
        super("types.Clause", [
            { no: 1, name: "hashed_keys", kind: "message", localName: "hashed_keys", oneof: "clause_type", T: () => HashedKeysClause },
            { no: 2, name: "keys", kind: "message", oneof: "clause_type", T: () => KeysClause },
            { no: 3, name: "member", kind: "message", oneof: "clause_type", T: () => MemberClause },
            { no: 4, name: "composite", kind: "message", oneof: "clause_type", T: () => CompositeClause }
        ]);
    }
    create(value?: PartialMessage<Clause>): Clause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clause_type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Clause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clause): Clause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.HashedKeysClause hashed_keys */ 1:
                    message.clause_type = {
                        oneofKind: "hashed_keys",
                        hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).hashed_keys)
                    };
                    break;
                case /* types.KeysClause keys */ 2:
                    message.clause_type = {
                        oneofKind: "keys",
                        keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).keys)
                    };
                    break;
                case /* types.MemberClause member */ 3:
                    message.clause_type = {
                        oneofKind: "member",
                        member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).member)
                    };
                    break;
                case /* types.CompositeClause composite */ 4:
                    message.clause_type = {
                        oneofKind: "composite",
                        composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).composite)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Clause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.HashedKeysClause hashed_keys = 1; */
        if (message.clause_type.oneofKind === "hashed_keys")
            HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.KeysClause keys = 2; */
        if (message.clause_type.oneofKind === "keys")
            KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.MemberClause member = 3; */
        if (message.clause_type.oneofKind === "member")
            MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.CompositeClause composite = 4; */
        if (message.clause_type.oneofKind === "composite")
            CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Clause
 */
export const Clause = new Clause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeysClause$Type extends MessageType<KeysClause> {
    constructor() {
        super("types.KeysClause", [
            { no: 2, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pattern_matching", kind: "enum", localName: "pattern_matching", T: () => ["types.PatternMatching", PatternMatching] },
            { no: 4, name: "models", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeysClause>): KeysClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.pattern_matching = 0;
        message.models = [];
        if (value !== undefined)
            reflectionMergePartial<KeysClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeysClause): KeysClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes keys */ 2:
                    message.keys.push(reader.bytes());
                    break;
                case /* types.PatternMatching pattern_matching */ 3:
                    message.pattern_matching = reader.int32();
                    break;
                case /* repeated string models */ 4:
                    message.models.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes keys = 2; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.keys[i]);
        /* types.PatternMatching pattern_matching = 3; */
        if (message.pattern_matching !== 0)
            writer.tag(3, WireType.Varint).int32(message.pattern_matching);
        /* repeated string models = 4; */
        for (let i = 0; i < message.models.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.models[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KeysClause
 */
export const KeysClause = new KeysClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HashedKeysClause$Type extends MessageType<HashedKeysClause> {
    constructor() {
        super("types.HashedKeysClause", [
            { no: 1, name: "hashed_keys", kind: "scalar", localName: "hashed_keys", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HashedKeysClause>): HashedKeysClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashed_keys = [];
        if (value !== undefined)
            reflectionMergePartial<HashedKeysClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HashedKeysClause): HashedKeysClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes hashed_keys */ 1:
                    message.hashed_keys.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HashedKeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes hashed_keys = 1; */
        for (let i = 0; i < message.hashed_keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.HashedKeysClause
 */
export const HashedKeysClause = new HashedKeysClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberValue$Type extends MessageType<MemberValue> {
    constructor() {
        super("types.MemberValue", [
            { no: 1, name: "primitive", kind: "message", oneof: "value_type", T: () => Primitive },
            { no: 2, name: "string", kind: "scalar", oneof: "value_type", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "list", kind: "message", oneof: "value_type", T: () => MemberValueList }
        ]);
    }
    create(value?: PartialMessage<MemberValue>): MemberValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value_type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MemberValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValue): MemberValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Primitive primitive */ 1:
                    message.value_type = {
                        oneofKind: "primitive",
                        primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).primitive)
                    };
                    break;
                case /* string string */ 2:
                    message.value_type = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                case /* types.MemberValueList list */ 3:
                    message.value_type = {
                        oneofKind: "list",
                        list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).list)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Primitive primitive = 1; */
        if (message.value_type.oneofKind === "primitive")
            Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string string = 2; */
        if (message.value_type.oneofKind === "string")
            writer.tag(2, WireType.LengthDelimited).string(message.value_type.string);
        /* types.MemberValueList list = 3; */
        if (message.value_type.oneofKind === "list")
            MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberValue
 */
export const MemberValue = new MemberValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberValueList$Type extends MessageType<MemberValueList> {
    constructor() {
        super("types.MemberValueList", [
            { no: 1, name: "values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MemberValue }
        ]);
    }
    create(value?: PartialMessage<MemberValueList>): MemberValueList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<MemberValueList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValueList): MemberValueList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.MemberValue values */ 1:
                    message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberValueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.MemberValue values = 1; */
        for (let i = 0; i < message.values.length; i++)
            MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberValueList
 */
export const MemberValueList = new MemberValueList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberClause$Type extends MessageType<MemberClause> {
    constructor() {
        super("types.MemberClause", [
            { no: 2, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "member", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "operator", kind: "enum", T: () => ["types.ComparisonOperator", ComparisonOperator] },
            { no: 5, name: "value", kind: "message", T: () => MemberValue }
        ]);
    }
    create(value?: PartialMessage<MemberClause>): MemberClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.model = "";
        message.member = "";
        message.operator = 0;
        if (value !== undefined)
            reflectionMergePartial<MemberClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberClause): MemberClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string model */ 2:
                    message.model = reader.string();
                    break;
                case /* string member */ 3:
                    message.member = reader.string();
                    break;
                case /* types.ComparisonOperator operator */ 4:
                    message.operator = reader.int32();
                    break;
                case /* types.MemberValue value */ 5:
                    message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string model = 2; */
        if (message.model !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.model);
        /* string member = 3; */
        if (message.member !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.member);
        /* types.ComparisonOperator operator = 4; */
        if (message.operator !== 0)
            writer.tag(4, WireType.Varint).int32(message.operator);
        /* types.MemberValue value = 5; */
        if (message.value)
            MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberClause
 */
export const MemberClause = new MemberClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompositeClause$Type extends MessageType<CompositeClause> {
    constructor() {
        super("types.CompositeClause", [
            { no: 3, name: "operator", kind: "enum", T: () => ["types.LogicalOperator", LogicalOperator] },
            { no: 4, name: "clauses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<CompositeClause>): CompositeClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operator = 0;
        message.clauses = [];
        if (value !== undefined)
            reflectionMergePartial<CompositeClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompositeClause): CompositeClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.LogicalOperator operator */ 3:
                    message.operator = reader.int32();
                    break;
                case /* repeated types.Clause clauses */ 4:
                    message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompositeClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.LogicalOperator operator = 3; */
        if (message.operator !== 0)
            writer.tag(3, WireType.Varint).int32(message.operator);
        /* repeated types.Clause clauses = 4; */
        for (let i = 0; i < message.clauses.length; i++)
            Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CompositeClause
 */
export const CompositeClause = new CompositeClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("types.Token", [
            { no: 1, name: "token_id", kind: "scalar", localName: "token_id", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "total_supply", kind: "scalar", localName: "total_supply", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.name = "";
        message.symbol = "";
        message.decimals = 0;
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes token_id */ 1:
                    message.token_id = reader.bytes();
                    break;
                case /* bytes contract_address */ 2:
                    message.contract_address = reader.bytes();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 4:
                    message.symbol = reader.string();
                    break;
                case /* uint32 decimals */ 5:
                    message.decimals = reader.uint32();
                    break;
                case /* bytes metadata */ 6:
                    message.metadata = reader.bytes();
                    break;
                case /* optional bytes total_supply */ 7:
                    message.total_supply = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes token_id = 1; */
        if (message.token_id !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.token_id);
        /* bytes contract_address = 2; */
        if (message.contract_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string symbol = 4; */
        if (message.symbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.symbol);
        /* uint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).uint32(message.decimals);
        /* bytes metadata = 6; */
        if (message.metadata.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.metadata);
        /* optional bytes total_supply = 7; */
        if (message.total_supply !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.total_supply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenCollection$Type extends MessageType<TokenCollection> {
    constructor() {
        super("types.TokenCollection", [
            { no: 2, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenCollection>): TokenCollection {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.name = "";
        message.symbol = "";
        message.decimals = 0;
        message.count = 0;
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TokenCollection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenCollection): TokenCollection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 2:
                    message.contract_address = reader.bytes();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 4:
                    message.symbol = reader.string();
                    break;
                case /* uint32 decimals */ 5:
                    message.decimals = reader.uint32();
                    break;
                case /* uint32 count */ 6:
                    message.count = reader.uint32();
                    break;
                case /* bytes metadata */ 7:
                    message.metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenCollection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 2; */
        if (message.contract_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string symbol = 4; */
        if (message.symbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.symbol);
        /* uint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).uint32(message.decimals);
        /* uint32 count = 6; */
        if (message.count !== 0)
            writer.tag(6, WireType.Varint).uint32(message.count);
        /* bytes metadata = 7; */
        if (message.metadata.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenCollection
 */
export const TokenCollection = new TokenCollection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenBalance$Type extends MessageType<TokenBalance> {
    constructor() {
        super("types.TokenBalance", [
            { no: 1, name: "balance", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "account_address", kind: "scalar", localName: "account_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_id", kind: "scalar", localName: "token_id", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenBalance>): TokenBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balance = new Uint8Array(0);
        message.account_address = new Uint8Array(0);
        message.contract_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TokenBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalance): TokenBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes balance */ 1:
                    message.balance = reader.bytes();
                    break;
                case /* bytes account_address */ 2:
                    message.account_address = reader.bytes();
                    break;
                case /* bytes contract_address */ 3:
                    message.contract_address = reader.bytes();
                    break;
                case /* optional bytes token_id */ 4:
                    message.token_id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes balance = 1; */
        if (message.balance.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.balance);
        /* bytes account_address = 2; */
        if (message.account_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.account_address);
        /* bytes contract_address = 3; */
        if (message.contract_address.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_address);
        /* optional bytes token_id = 4; */
        if (message.token_id !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenBalance
 */
export const TokenBalance = new TokenBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderBy$Type extends MessageType<OrderBy> {
    constructor() {
        super("types.OrderBy", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "direction", kind: "enum", T: () => ["types.OrderDirection", OrderDirection] }
        ]);
    }
    create(value?: PartialMessage<OrderBy>): OrderBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = "";
        message.direction = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBy): OrderBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* types.OrderDirection direction */ 2:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* types.OrderDirection direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OrderBy
 */
export const OrderBy = new OrderBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Controller$Type extends MessageType<Controller> {
    constructor() {
        super("types.Controller", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deployed_at_timestamp", kind: "scalar", localName: "deployed_at_timestamp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Controller>): Controller {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = new Uint8Array(0);
        message.username = "";
        message.deployed_at_timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Controller>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Controller): Controller {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* uint64 deployed_at_timestamp */ 3:
                    message.deployed_at_timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Controller, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* uint64 deployed_at_timestamp = 3; */
        if (message.deployed_at_timestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.deployed_at_timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Controller
 */
export const Controller = new Controller$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pagination$Type extends MessageType<Pagination> {
    constructor() {
        super("types.Pagination", [
            { no: 1, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "direction", kind: "enum", T: () => ["types.PaginationDirection", PaginationDirection] },
            { no: 4, name: "order_by", kind: "message", localName: "order_by", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderBy }
        ]);
    }
    create(value?: PartialMessage<Pagination>): Pagination {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cursor = "";
        message.limit = 0;
        message.direction = 0;
        message.order_by = [];
        if (value !== undefined)
            reflectionMergePartial<Pagination>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination): Pagination {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cursor */ 1:
                    message.cursor = reader.string();
                    break;
                case /* uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                case /* types.PaginationDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                case /* repeated types.OrderBy order_by */ 4:
                    message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pagination, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cursor = 1; */
        if (message.cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cursor);
        /* uint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        /* types.PaginationDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        /* repeated types.OrderBy order_by = 4; */
        for (let i = 0; i < message.order_by.length; i++)
            OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Pagination
 */
export const Pagination = new Pagination$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControllerQuery$Type extends MessageType<ControllerQuery> {
    constructor() {
        super("types.ControllerQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "usernames", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<ControllerQuery>): ControllerQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.usernames = [];
        if (value !== undefined)
            reflectionMergePartial<ControllerQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerQuery): ControllerQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated string usernames */ 2:
                    message.usernames.push(reader.string());
                    break;
                case /* types.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControllerQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated string usernames = 2; */
        for (let i = 0; i < message.usernames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.usernames[i]);
        /* types.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ControllerQuery
 */
export const ControllerQuery = new ControllerQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenQuery$Type extends MessageType<TokenQuery> {
    constructor() {
        super("types.TokenQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenQuery>): TokenQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<TokenQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenQuery): TokenQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 2:
                    message.token_ids.push(reader.bytes());
                    break;
                case /* types.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 2; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
        /* types.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenQuery
 */
export const TokenQuery = new TokenQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenBalanceQuery$Type extends MessageType<TokenBalanceQuery> {
    constructor() {
        super("types.TokenBalanceQuery", [
            { no: 1, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenBalanceQuery>): TokenBalanceQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<TokenBalanceQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalanceQuery): TokenBalanceQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenBalanceQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenBalanceQuery
 */
export const TokenBalanceQuery = new TokenBalanceQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionCall$Type extends MessageType<TransactionCall> {
    constructor() {
        super("types.TransactionCall", [
            { no: 1, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "entrypoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "calldata", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "call_type", kind: "enum", localName: "call_type", T: () => ["types.CallType", CallType] },
            { no: 5, name: "caller_address", kind: "scalar", localName: "caller_address", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionCall>): TransactionCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.entrypoint = "";
        message.calldata = [];
        message.call_type = 0;
        message.caller_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TransactionCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionCall): TransactionCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                case /* string entrypoint */ 2:
                    message.entrypoint = reader.string();
                    break;
                case /* repeated bytes calldata */ 3:
                    message.calldata.push(reader.bytes());
                    break;
                case /* types.CallType call_type */ 4:
                    message.call_type = reader.int32();
                    break;
                case /* bytes caller_address */ 5:
                    message.caller_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
        /* string entrypoint = 2; */
        if (message.entrypoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entrypoint);
        /* repeated bytes calldata = 3; */
        for (let i = 0; i < message.calldata.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
        /* types.CallType call_type = 4; */
        if (message.call_type !== 0)
            writer.tag(4, WireType.Varint).int32(message.call_type);
        /* bytes caller_address = 5; */
        if (message.caller_address.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.caller_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionCall
 */
export const TransactionCall = new TransactionCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("types.Transaction", [
            { no: 1, name: "transaction_hash", kind: "scalar", localName: "transaction_hash", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sender_address", kind: "scalar", localName: "sender_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "calldata", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "max_fee", kind: "scalar", localName: "max_fee", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "signature", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "block_number", kind: "scalar", localName: "block_number", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "transaction_type", kind: "scalar", localName: "transaction_type", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "block_timestamp", kind: "scalar", localName: "block_timestamp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "calls", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TransactionCall },
            { no: 11, name: "unique_models", kind: "scalar", localName: "unique_models", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transaction_hash = new Uint8Array(0);
        message.sender_address = new Uint8Array(0);
        message.calldata = [];
        message.max_fee = new Uint8Array(0);
        message.signature = [];
        message.nonce = new Uint8Array(0);
        message.block_number = 0n;
        message.transaction_type = "";
        message.block_timestamp = 0n;
        message.calls = [];
        message.unique_models = [];
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes transaction_hash */ 1:
                    message.transaction_hash = reader.bytes();
                    break;
                case /* bytes sender_address */ 2:
                    message.sender_address = reader.bytes();
                    break;
                case /* repeated bytes calldata */ 3:
                    message.calldata.push(reader.bytes());
                    break;
                case /* bytes max_fee */ 4:
                    message.max_fee = reader.bytes();
                    break;
                case /* repeated bytes signature */ 5:
                    message.signature.push(reader.bytes());
                    break;
                case /* bytes nonce */ 6:
                    message.nonce = reader.bytes();
                    break;
                case /* uint64 block_number */ 7:
                    message.block_number = reader.uint64().toBigInt();
                    break;
                case /* string transaction_type */ 8:
                    message.transaction_type = reader.string();
                    break;
                case /* uint64 block_timestamp */ 9:
                    message.block_timestamp = reader.uint64().toBigInt();
                    break;
                case /* repeated types.TransactionCall calls */ 10:
                    message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated bytes unique_models */ 11:
                    message.unique_models.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes transaction_hash = 1; */
        if (message.transaction_hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hash);
        /* bytes sender_address = 2; */
        if (message.sender_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sender_address);
        /* repeated bytes calldata = 3; */
        for (let i = 0; i < message.calldata.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
        /* bytes max_fee = 4; */
        if (message.max_fee.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.max_fee);
        /* repeated bytes signature = 5; */
        for (let i = 0; i < message.signature.length; i++)
            writer.tag(5, WireType.LengthDelimited).bytes(message.signature[i]);
        /* bytes nonce = 6; */
        if (message.nonce.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.nonce);
        /* uint64 block_number = 7; */
        if (message.block_number !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.block_number);
        /* string transaction_type = 8; */
        if (message.transaction_type !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.transaction_type);
        /* uint64 block_timestamp = 9; */
        if (message.block_timestamp !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.block_timestamp);
        /* repeated types.TransactionCall calls = 10; */
        for (let i = 0; i < message.calls.length; i++)
            TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes unique_models = 11; */
        for (let i = 0; i < message.unique_models.length; i++)
            writer.tag(11, WireType.LengthDelimited).bytes(message.unique_models[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionFilter$Type extends MessageType<TransactionFilter> {
    constructor() {
        super("types.TransactionFilter", [
            { no: 1, name: "transaction_hashes", kind: "scalar", localName: "transaction_hashes", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "caller_addresses", kind: "scalar", localName: "caller_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "entrypoints", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "model_selectors", kind: "scalar", localName: "model_selectors", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "from_block", kind: "scalar", localName: "from_block", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "to_block", kind: "scalar", localName: "to_block", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionFilter>): TransactionFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transaction_hashes = [];
        message.caller_addresses = [];
        message.contract_addresses = [];
        message.entrypoints = [];
        message.model_selectors = [];
        if (value !== undefined)
            reflectionMergePartial<TransactionFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionFilter): TransactionFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes transaction_hashes */ 1:
                    message.transaction_hashes.push(reader.bytes());
                    break;
                case /* repeated bytes caller_addresses */ 2:
                    message.caller_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 3:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated string entrypoints */ 4:
                    message.entrypoints.push(reader.string());
                    break;
                case /* repeated bytes model_selectors */ 5:
                    message.model_selectors.push(reader.bytes());
                    break;
                case /* optional uint64 from_block */ 6:
                    message.from_block = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 to_block */ 7:
                    message.to_block = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes transaction_hashes = 1; */
        for (let i = 0; i < message.transaction_hashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hashes[i]);
        /* repeated bytes caller_addresses = 2; */
        for (let i = 0; i < message.caller_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
        /* repeated bytes contract_addresses = 3; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated string entrypoints = 4; */
        for (let i = 0; i < message.entrypoints.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.entrypoints[i]);
        /* repeated bytes model_selectors = 5; */
        for (let i = 0; i < message.model_selectors.length; i++)
            writer.tag(5, WireType.LengthDelimited).bytes(message.model_selectors[i]);
        /* optional uint64 from_block = 6; */
        if (message.from_block !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.from_block);
        /* optional uint64 to_block = 7; */
        if (message.to_block !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.to_block);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionFilter
 */
export const TransactionFilter = new TransactionFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionQuery$Type extends MessageType<TransactionQuery> {
    constructor() {
        super("types.TransactionQuery", [
            { no: 1, name: "filter", kind: "message", T: () => TransactionFilter },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TransactionQuery>): TransactionQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TransactionQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionQuery): TransactionQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* types.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionQuery
 */
export const TransactionQuery = new TransactionQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contract$Type extends MessageType<Contract> {
    constructor() {
        super("types.Contract", [
            { no: 1, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
            { no: 3, name: "head", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tps", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "last_block_timestamp", kind: "scalar", localName: "last_block_timestamp", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_pending_block_tx", kind: "scalar", localName: "last_pending_block_tx", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Contract>): Contract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.contract_type = 0;
        message.updated_at = 0n;
        message.created_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<Contract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                case /* types.ContractType contract_type */ 2:
                    message.contract_type = reader.int32();
                    break;
                case /* optional uint64 head */ 3:
                    message.head = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 tps */ 4:
                    message.tps = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 last_block_timestamp */ 5:
                    message.last_block_timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional bytes last_pending_block_tx */ 6:
                    message.last_pending_block_tx = reader.bytes();
                    break;
                case /* uint64 updated_at */ 7:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_at */ 8:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
        /* types.ContractType contract_type = 2; */
        if (message.contract_type !== 0)
            writer.tag(2, WireType.Varint).int32(message.contract_type);
        /* optional uint64 head = 3; */
        if (message.head !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.head);
        /* optional uint64 tps = 4; */
        if (message.tps !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.tps);
        /* optional uint64 last_block_timestamp = 5; */
        if (message.last_block_timestamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.last_block_timestamp);
        /* optional bytes last_pending_block_tx = 6; */
        if (message.last_pending_block_tx !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.last_pending_block_tx);
        /* uint64 updated_at = 7; */
        if (message.updated_at !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.updated_at);
        /* uint64 created_at = 8; */
        if (message.created_at !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.created_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Contract
 */
export const Contract = new Contract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractQuery$Type extends MessageType<ContractQuery> {
    constructor() {
        super("types.ContractQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1 /*RepeatType.PACKED*/, T: () => ["types.ContractType", ContractType] }
        ]);
    }
    create(value?: PartialMessage<ContractQuery>): ContractQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.contract_types = [];
        if (value !== undefined)
            reflectionMergePartial<ContractQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractQuery): ContractQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated types.ContractType contract_types */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.contract_types.push(reader.int32());
                    else
                        message.contract_types.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated types.ContractType contract_types = 2; */
        if (message.contract_types.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.contract_types.length; i++)
                writer.int32(message.contract_types[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ContractQuery
 */
export const ContractQuery = new ContractQuery$Type();
