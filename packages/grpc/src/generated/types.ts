// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "types.proto" (package "types", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Primitive } from "./schema";
import { Struct } from "./schema";
/**
 * @generated from protobuf message types.World
 */
export interface World {
    /**
     * The hex-encoded address of the world.
     *
     * @generated from protobuf field: string world_address = 1
     */
    world_address: string;
    /**
     * A list of metadata for all registered components in the world.
     *
     * @generated from protobuf field: repeated types.Model models = 2
     */
    models: Model[];
}
/**
 * @generated from protobuf message types.Model
 */
export interface Model {
    /**
     * Model selector
     *
     * @generated from protobuf field: bytes selector = 1
     */
    selector: Uint8Array;
    /**
     * Model namespace
     *
     * @generated from protobuf field: string namespace = 2
     */
    namespace: string;
    /**
     * Model name
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * Model size when it is packed for storage
     *
     * @generated from protobuf field: uint32 packed_size = 4
     */
    packed_size: number;
    /**
     * Model size when it is unpacked
     *
     * @generated from protobuf field: uint32 unpacked_size = 5
     */
    unpacked_size: number;
    /**
     * felt bytes of the class hash of the component
     *
     * @generated from protobuf field: bytes class_hash = 6
     */
    class_hash: Uint8Array;
    /**
     * The layout of the component in bytes
     *
     * @generated from protobuf field: bytes layout = 7
     */
    layout: Uint8Array;
    /**
     * The schema of the component serialized in bytes (for simplicity sake)
     *
     * @generated from protobuf field: bytes schema = 8
     */
    schema: Uint8Array;
    /**
     * felt bytes of the contract address of the component
     *
     * @generated from protobuf field: bytes contract_address = 9
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: bool use_legacy_store = 10
     */
    use_legacy_store: boolean;
    /**
     * The world address of the model
     *
     * @generated from protobuf field: bytes world_address = 11
     */
    world_address: Uint8Array;
}
/**
 * @generated from protobuf message types.Entity
 */
export interface Entity {
    /**
     * The entity's hashed keys
     *
     * @generated from protobuf field: bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array;
    /**
     * Models of the entity
     *
     * @generated from protobuf field: repeated types.Struct models = 2
     */
    models: Struct[];
    /**
     * Created at timestamp
     *
     * @generated from protobuf field: uint64 created_at = 3
     */
    created_at: bigint;
    /**
     * Updated at timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 4
     */
    updated_at: bigint;
    /**
     * Block timestamp when the entity was updated
     *
     * @generated from protobuf field: uint64 executed_at = 5
     */
    executed_at: bigint;
    /**
     * The world address of the entity
     *
     * @generated from protobuf field: bytes world_address = 6
     */
    world_address: Uint8Array;
}
/**
 * @generated from protobuf message types.Event
 */
export interface Event {
    /**
     * The event's keys
     *
     * @generated from protobuf field: repeated bytes keys = 1
     */
    keys: Uint8Array[];
    /**
     * Data of the event
     *
     * @generated from protobuf field: repeated bytes data = 2
     */
    data: Uint8Array[];
    /**
     * event's transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 3
     */
    transaction_hash: Uint8Array;
}
/**
 * @generated from protobuf message types.Query
 */
export interface Query {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
    /**
     * @generated from protobuf field: bool no_hashed_keys = 2
     */
    no_hashed_keys: boolean;
    /**
     * @generated from protobuf field: repeated string models = 3
     */
    models: string[];
    /**
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
    /**
     * @generated from protobuf field: bool historical = 5
     */
    historical: boolean;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 6
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated from protobuf message types.EventQuery
 */
export interface EventQuery {
    /**
     * @generated from protobuf field: types.KeysClause keys = 1
     */
    keys?: KeysClause;
    /**
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message types.Clause
 */
export interface Clause {
    /**
     * @generated from protobuf oneof: clause_type
     */
    clause_type: {
        oneofKind: "hashed_keys";
        /**
         * @generated from protobuf field: types.HashedKeysClause hashed_keys = 1
         */
        hashed_keys: HashedKeysClause;
    } | {
        oneofKind: "keys";
        /**
         * @generated from protobuf field: types.KeysClause keys = 2
         */
        keys: KeysClause;
    } | {
        oneofKind: "member";
        /**
         * @generated from protobuf field: types.MemberClause member = 3
         */
        member: MemberClause;
    } | {
        oneofKind: "composite";
        /**
         * @generated from protobuf field: types.CompositeClause composite = 4
         */
        composite: CompositeClause;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message types.KeysClause
 */
export interface KeysClause {
    /**
     * @generated from protobuf field: repeated bytes keys = 2
     */
    keys: Uint8Array[];
    /**
     * @generated from protobuf field: types.PatternMatching pattern_matching = 3
     */
    pattern_matching: PatternMatching;
    /**
     * @generated from protobuf field: repeated string models = 4
     */
    models: string[];
}
/**
 * @generated from protobuf message types.HashedKeysClause
 */
export interface HashedKeysClause {
    /**
     * @generated from protobuf field: repeated bytes hashed_keys = 1
     */
    hashed_keys: Uint8Array[];
}
/**
 * @generated from protobuf message types.MemberValue
 */
export interface MemberValue {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "primitive";
        /**
         * @generated from protobuf field: types.Primitive primitive = 1
         */
        primitive: Primitive;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 2
         */
        string: string;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: types.MemberValueList list = 3
         */
        list: MemberValueList;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message types.MemberValueList
 */
export interface MemberValueList {
    /**
     * @generated from protobuf field: repeated types.MemberValue values = 1
     */
    values: MemberValue[];
}
/**
 * @generated from protobuf message types.MemberClause
 */
export interface MemberClause {
    /**
     * @generated from protobuf field: string model = 2
     */
    model: string;
    /**
     * @generated from protobuf field: string member = 3
     */
    member: string;
    /**
     * @generated from protobuf field: types.ComparisonOperator operator = 4
     */
    operator: ComparisonOperator;
    /**
     * @generated from protobuf field: types.MemberValue value = 5
     */
    value?: MemberValue;
}
/**
 * @generated from protobuf message types.CompositeClause
 */
export interface CompositeClause {
    /**
     * @generated from protobuf field: types.LogicalOperator operator = 3
     */
    operator: LogicalOperator;
    /**
     * @generated from protobuf field: repeated types.Clause clauses = 4
     */
    clauses: Clause[];
}
/**
 * @generated from protobuf message types.Token
 */
export interface Token {
    /**
     * @generated from protobuf field: optional bytes token_id = 1
     */
    token_id?: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
}
/**
 * @generated from protobuf message types.TokenBalance
 */
export interface TokenBalance {
    /**
     * @generated from protobuf field: bytes balance = 1
     */
    balance: Uint8Array;
    /**
     * @generated from protobuf field: bytes account_address = 2
     */
    account_address: Uint8Array;
    /**
     * @generated from protobuf field: bytes contract_address = 3
     */
    contract_address: Uint8Array;
    /**
     * @generated from protobuf field: optional bytes token_id = 4
     */
    token_id?: Uint8Array;
}
/**
 * @generated from protobuf message types.OrderBy
 */
export interface OrderBy {
    /**
     * @generated from protobuf field: string field = 1
     */
    field: string;
    /**
     * @generated from protobuf field: types.OrderDirection direction = 2
     */
    direction: OrderDirection;
}
/**
 * @generated from protobuf message types.Controller
 */
export interface Controller {
    /**
     * @generated from protobuf field: bytes address = 1
     */
    address: Uint8Array;
    /**
     * @generated from protobuf field: string username = 2
     */
    username: string;
    /**
     * @generated from protobuf field: uint64 deployed_at_timestamp = 3
     */
    deployed_at_timestamp: bigint;
}
/**
 * @generated from protobuf message types.Pagination
 */
export interface Pagination {
    /**
     * @generated from protobuf field: string cursor = 1
     */
    cursor: string;
    /**
     * @generated from protobuf field: uint32 limit = 2
     */
    limit: number;
    /**
     * @generated from protobuf field: types.PaginationDirection direction = 3
     */
    direction: PaginationDirection;
    /**
     * @generated from protobuf field: repeated types.OrderBy order_by = 4
     */
    order_by: OrderBy[];
}
/**
 * @generated from protobuf message types.ControllerQuery
 */
export interface ControllerQuery {
    /**
     * The list of contract addresses to retrieve controllers for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of usernames to retrieve controllers for
     *
     * @generated from protobuf field: repeated string usernames = 2
     */
    usernames: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * Token attribute filter for filtering tokens by their metadata attributes
 *
 * @generated from protobuf message types.TokenAttributeFilter
 */
export interface TokenAttributeFilter {
    /**
     * The name of the trait/attribute to filter by
     *
     * @generated from protobuf field: string trait_name = 1
     */
    trait_name: string;
    /**
     * The value of the trait/attribute to filter by
     *
     * @generated from protobuf field: string trait_value = 2
     */
    trait_value: string;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message types.TokenQuery
 */
export interface TokenQuery {
    /**
     * The list of contract addresses to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve tokens for
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
    /**
     * The list of attribute filters to apply
     *
     * @generated from protobuf field: repeated types.TokenAttributeFilter attribute_filters = 3
     */
    attribute_filters: TokenAttributeFilter[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message types.TokenBalanceQuery
 */
export interface TokenBalanceQuery {
    /**
     * The account addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to retrieve balances for
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message types.TokenContractQuery
 */
export interface TokenContractQuery {
    /**
     * The list of contract addresses to retrieve token contracts for
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * A token transfer record
 *
 * @generated from protobuf message types.TokenTransfer
 */
export interface TokenTransfer {
    /**
     * Unique identifier for the transfer (event_id:token_id key)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Contract address of the token
     *
     * @generated from protobuf field: bytes contract_address = 2
     */
    contract_address: Uint8Array;
    /**
     * Sender address
     *
     * @generated from protobuf field: bytes from_address = 3
     */
    from_address: Uint8Array;
    /**
     * Recipient address
     *
     * @generated from protobuf field: bytes to_address = 4
     */
    to_address: Uint8Array;
    /**
     * Amount transferred (big-endian bytes)
     *
     * @generated from protobuf field: bytes amount = 5
     */
    amount: Uint8Array;
    /**
     * Token ID when applicable (ERC721/1155); omitted for ERC20
     *
     * @generated from protobuf field: optional bytes token_id = 6
     */
    token_id?: Uint8Array;
    /**
     * Executed at timestamp (seconds since epoch)
     *
     * @generated from protobuf field: uint64 executed_at = 7
     */
    executed_at: bigint;
    /**
     * Optional event id that originated this transfer
     *
     * @generated from protobuf field: optional string event_id = 8
     */
    event_id?: string;
}
/**
 * A request to retrieve token transfers
 *
 * @generated from protobuf message types.TokenTransferQuery
 */
export interface TokenTransferQuery {
    /**
     * Filter by any of these account addresses (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * Filter by token contract addresses
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * Filter by token IDs (bytes of numeric id)
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * @generated from protobuf message types.TransactionCall
 */
export interface TransactionCall {
    /**
     * The contract address being called
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The function name being called
     *
     * @generated from protobuf field: string entrypoint = 2
     */
    entrypoint: string;
    /**
     * The calldata for the function call
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)
     *
     * @generated from protobuf field: types.CallType call_type = 4
     */
    call_type: CallType;
    /**
     * The address making the call
     *
     * @generated from protobuf field: bytes caller_address = 5
     */
    caller_address: Uint8Array;
}
/**
 * @generated from protobuf message types.Transaction
 */
export interface Transaction {
    /**
     * The transaction hash
     *
     * @generated from protobuf field: bytes transaction_hash = 1
     */
    transaction_hash: Uint8Array;
    /**
     * The sender address
     *
     * @generated from protobuf field: bytes sender_address = 2
     */
    sender_address: Uint8Array;
    /**
     * The transaction calldata
     *
     * @generated from protobuf field: repeated bytes calldata = 3
     */
    calldata: Uint8Array[];
    /**
     * The maximum fee for the transaction
     *
     * @generated from protobuf field: bytes max_fee = 4
     */
    max_fee: Uint8Array;
    /**
     * The transaction signature
     *
     * @generated from protobuf field: repeated bytes signature = 5
     */
    signature: Uint8Array[];
    /**
     * The transaction nonce
     *
     * @generated from protobuf field: bytes nonce = 6
     */
    nonce: Uint8Array;
    /**
     * The block number the transaction was included in
     *
     * @generated from protobuf field: uint64 block_number = 7
     */
    block_number: bigint;
    /**
     * The transaction type (INVOKE, L1_HANDLER, etc.)
     *
     * @generated from protobuf field: string transaction_type = 8
     */
    transaction_type: string;
    /**
     * The timestamp when the transaction was executed
     *
     * @generated from protobuf field: uint64 block_timestamp = 9
     */
    block_timestamp: bigint;
    /**
     * The parsed calls within the transaction
     *
     * @generated from protobuf field: repeated types.TransactionCall calls = 10
     */
    calls: TransactionCall[];
    /**
     * The unique models associated with this transaction
     *
     * @generated from protobuf field: repeated bytes unique_models = 11
     */
    unique_models: Uint8Array[];
}
/**
 * @generated from protobuf message types.TransactionFilter
 */
export interface TransactionFilter {
    /**
     * The list of transaction hashes to retrieve
     *
     * @generated from protobuf field: repeated bytes transaction_hashes = 1
     */
    transaction_hashes: Uint8Array[];
    /**
     * The list of caller addresses to filter by
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 2
     */
    caller_addresses: Uint8Array[];
    /**
     * The list of contract addresses to filter by (calls made to these contracts)
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 3
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of entrypoints to filter by
     *
     * @generated from protobuf field: repeated string entrypoints = 4
     */
    entrypoints: string[];
    /**
     * The list of model selectors to filter by
     *
     * @generated from protobuf field: repeated bytes model_selectors = 5
     */
    model_selectors: Uint8Array[];
    /**
     * The block number range to filter by
     *
     * @generated from protobuf field: optional uint64 from_block = 6
     */
    from_block?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_block = 7
     */
    to_block?: bigint;
}
/**
 * @generated from protobuf message types.TransactionQuery
 */
export interface TransactionQuery {
    /**
     * The filter to apply to the query
     *
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 2
     */
    pagination?: Pagination;
}
/**
 * Activity tracking for user sessions
 *
 * @generated from protobuf message types.Activity
 */
export interface Activity {
    /**
     * Unique identifier: world_address:namespace:caller_address:session_start_timestamp
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * World contract address
     *
     * @generated from protobuf field: bytes world_address = 2
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 3
     */
    namespace: string;
    /**
     * Caller address
     *
     * @generated from protobuf field: bytes caller_address = 4
     */
    caller_address: Uint8Array;
    /**
     * Session start time
     *
     * @generated from protobuf field: uint64 session_start = 5
     */
    session_start: bigint;
    /**
     * Session end time
     *
     * @generated from protobuf field: uint64 session_end = 6
     */
    session_end: bigint;
    /**
     * Total action count in session
     *
     * @generated from protobuf field: uint32 action_count = 7
     */
    action_count: number;
    /**
     * Map of action names to call counts
     *
     * @generated from protobuf field: map<string, uint32> actions = 8
     */
    actions: {
        [key: string]: number;
    };
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: uint64 updated_at = 9
     */
    updated_at: bigint;
}
/**
 * @generated from protobuf message types.ActivityQuery
 */
export interface ActivityQuery {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 3
     */
    caller_addresses: Uint8Array[];
    /**
     * Filter by time range (unix timestamps)
     *
     * @generated from protobuf field: optional uint64 from_time = 4
     */
    from_time?: bigint;
    /**
     * @generated from protobuf field: optional uint64 to_time = 5
     */
    to_time?: bigint;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 6
     */
    pagination?: Pagination;
}
/**
 * SQL query value types
 *
 * @generated from protobuf message types.SqlValue
 */
export interface SqlValue {
    /**
     * @generated from protobuf oneof: value_type
     */
    value_type: {
        oneofKind: "text";
        /**
         * @generated from protobuf field: string text = 1
         */
        text: string;
    } | {
        oneofKind: "integer";
        /**
         * @generated from protobuf field: int64 integer = 2
         */
        integer: bigint;
    } | {
        oneofKind: "real";
        /**
         * @generated from protobuf field: double real = 3
         */
        real: number;
    } | {
        oneofKind: "blob";
        /**
         * @generated from protobuf field: bytes blob = 4
         */
        blob: Uint8Array;
    } | {
        oneofKind: "null";
        /**
         * @generated from protobuf field: bool null = 5
         */
        null: boolean;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A single row from SQL query results
 *
 * @generated from protobuf message types.SqlRow
 */
export interface SqlRow {
    /**
     * Map of column name to value
     *
     * @generated from protobuf field: map<string, types.SqlValue> fields = 1
     */
    fields: {
        [key: string]: SqlValue;
    };
}
/**
 * A request to execute a SQL query
 *
 * @generated from protobuf message types.SqlQueryRequest
 */
export interface SqlQueryRequest {
    /**
     * The SQL query to execute
     *
     * @generated from protobuf field: string query = 1
     */
    query: string;
}
/**
 * A response containing SQL query results
 *
 * @generated from protobuf message types.SqlQueryResponse
 */
export interface SqlQueryResponse {
    /**
     * The rows returned by the query
     *
     * @generated from protobuf field: repeated types.SqlRow rows = 1
     */
    rows: SqlRow[];
}
/**
 * @generated from protobuf message types.Contract
 */
export interface Contract {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType;
    /**
     * Current block height
     *
     * @generated from protobuf field: optional uint64 head = 3
     */
    head?: bigint;
    /**
     * Transactions per second
     *
     * @generated from protobuf field: optional uint64 tps = 4
     */
    tps?: bigint;
    /**
     * Last block timestamp
     *
     * @generated from protobuf field: optional uint64 last_block_timestamp = 5
     */
    last_block_timestamp?: bigint;
    /**
     * Last pending block transaction
     *
     * @generated from protobuf field: optional bytes last_pending_block_tx = 6
     */
    last_pending_block_tx?: Uint8Array;
    /**
     * When the contract was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
    /**
     * When the contract was first tracked
     *
     * @generated from protobuf field: uint64 created_at = 8
     */
    created_at: bigint;
}
/**
 * A request to retrieve contracts
 *
 * @generated from protobuf message types.ContractQuery
 */
export interface ContractQuery {
    /**
     * The list of contract addresses to retrieve
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of contract types to filter by
     *
     * @generated from protobuf field: repeated types.ContractType contract_types = 2
     */
    contract_types: ContractType[];
}
/**
 * @generated from protobuf message types.TokenContract
 */
export interface TokenContract {
    /**
     * The contract address
     *
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
    /**
     * The type of contract
     *
     * @generated from protobuf field: types.ContractType contract_type = 2
     */
    contract_type: ContractType;
    /**
     * The name of the contract
     *
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * The symbol of the contract
     *
     * @generated from protobuf field: string symbol = 4
     */
    symbol: string;
    /**
     * The decimals of the contract
     *
     * @generated from protobuf field: uint32 decimals = 5
     */
    decimals: number;
    /**
     * The metadata of the contract
     *
     * @generated from protobuf field: bytes metadata = 6
     */
    metadata: Uint8Array;
    /**
     * The total supply of the contract
     *
     * @generated from protobuf field: optional bytes total_supply = 7
     */
    total_supply?: Uint8Array;
    /**
     * The traits of the contract (JSON object with trait types and possible values)
     *
     * @generated from protobuf field: string traits = 8
     */
    traits: string;
    /**
     * The first token metadata of the contract
     *
     * @generated from protobuf field: bytes token_metadata = 9
     */
    token_metadata: Uint8Array;
}
/**
 * A query for aggregations (leaderboards, stats, rankings)
 *
 * @generated from protobuf message types.AggregationQuery
 */
export interface AggregationQuery {
    /**
     * The list of aggregator IDs to retrieve (e.g., "top_scores", "most_wins")
     *
     * @generated from protobuf field: repeated string aggregator_ids = 1
     */
    aggregator_ids: string[];
    /**
     * The list of entity IDs to filter by (optional)
     *
     * @generated from protobuf field: repeated string entity_ids = 2
     */
    entity_ids: string[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 3
     */
    pagination?: Pagination;
}
/**
 * An entry in an aggregation with its calculated position
 *
 * @generated from protobuf message types.AggregationEntry
 */
export interface AggregationEntry {
    /**
     * Unique identifier for this entry
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * The aggregator this entry belongs to
     *
     * @generated from protobuf field: string aggregator_id = 2
     */
    aggregator_id: string;
    /**
     * The entity being ranked
     *
     * @generated from protobuf field: string entity_id = 3
     */
    entity_id: string;
    /**
     * Normalized value for ordering (zero-padded hex)
     *
     * @generated from protobuf field: bytes value = 4
     */
    value: Uint8Array;
    /**
     * Display value for presentation (original format)
     *
     * @generated from protobuf field: string display_value = 5
     */
    display_value: string;
    /**
     * Calculated position/rank (1-indexed)
     *
     * @generated from protobuf field: uint64 position = 6
     */
    position: bigint;
    /**
     * The model ID this aggregation is based on
     *
     * @generated from protobuf field: string model_id = 7
     */
    model_id: string;
    /**
     * When the entry was created (RFC3339 timestamp)
     *
     * @generated from protobuf field: string created_at = 8
     */
    created_at: string;
    /**
     * When the entry was last updated (RFC3339 timestamp)
     *
     * @generated from protobuf field: string updated_at = 9
     */
    updated_at: string;
}
/**
 * Achievement definition
 *
 * @generated from protobuf message types.Achievement
 */
export interface Achievement {
    /**
     * Achievement ID (unique identifier)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * World contract address
     *
     * @generated from protobuf field: bytes world_address = 2
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 3
     */
    namespace: string;
    /**
     * Entity ID from on-chain
     *
     * @generated from protobuf field: string entity_id = 4
     */
    entity_id: string;
    /**
     * Is this achievement hidden
     *
     * @generated from protobuf field: bool hidden = 5
     */
    hidden: boolean;
    /**
     * Display index/order
     *
     * @generated from protobuf field: uint32 index = 6
     */
    index: number;
    /**
     * Points awarded for completion
     *
     * @generated from protobuf field: uint32 points = 7
     */
    points: number;
    /**
     * Start time
     *
     * @generated from protobuf field: string start = 8
     */
    start: string;
    /**
     * End time
     *
     * @generated from protobuf field: string end = 9
     */
    end: string;
    /**
     * Achievement group
     *
     * @generated from protobuf field: string group = 10
     */
    group: string;
    /**
     * Icon identifier
     *
     * @generated from protobuf field: string icon = 11
     */
    icon: string;
    /**
     * Achievement title
     *
     * @generated from protobuf field: string title = 12
     */
    title: string;
    /**
     * Achievement description
     *
     * @generated from protobuf field: string description = 13
     */
    description: string;
    /**
     * Tasks to complete for this achievement
     *
     * @generated from protobuf field: repeated types.AchievementTask tasks = 14
     */
    tasks: AchievementTask[];
    /**
     * Additional data (JSON)
     *
     * @generated from protobuf field: optional string data = 15
     */
    data?: string;
    /**
     * Total completions across all players
     *
     * @generated from protobuf field: uint32 total_completions = 16
     */
    total_completions: number;
    /**
     * Completion rate (percentage 0-100)
     *
     * @generated from protobuf field: double completion_rate = 17
     */
    completion_rate: number;
    /**
     * When the achievement was created
     *
     * @generated from protobuf field: uint64 created_at = 18
     */
    created_at: bigint;
    /**
     * When the achievement was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 19
     */
    updated_at: bigint;
}
/**
 * A task within an achievement
 *
 * @generated from protobuf message types.AchievementTask
 */
export interface AchievementTask {
    /**
     * Task ID from on-chain (unique within achievement)
     *
     * @generated from protobuf field: string task_id = 1
     */
    task_id: string;
    /**
     * Task description
     *
     * @generated from protobuf field: string description = 2
     */
    description: string;
    /**
     * Target count to complete this task
     *
     * @generated from protobuf field: uint32 total = 3
     */
    total: number;
    /**
     * Total completions across all players
     *
     * @generated from protobuf field: uint32 total_completions = 4
     */
    total_completions: number;
    /**
     * Completion rate (percentage 0-100)
     *
     * @generated from protobuf field: double completion_rate = 5
     */
    completion_rate: number;
    /**
     * When the task was created
     *
     * @generated from protobuf field: uint64 created_at = 6
     */
    created_at: bigint;
}
/**
 * Player's global achievement statistics (across all worlds/namespaces)
 *
 * @generated from protobuf message types.PlayerAchievementStats
 */
export interface PlayerAchievementStats {
    /**
     * Total points earned across all games
     *
     * @generated from protobuf field: uint32 total_points = 1
     */
    total_points: number;
    /**
     * Number of achievements completed across all games
     *
     * @generated from protobuf field: uint32 completed_achievements = 2
     */
    completed_achievements: number;
    /**
     * Total achievements available across all games
     *
     * @generated from protobuf field: uint32 total_achievements = 3
     */
    total_achievements: number;
    /**
     * Overall completion percentage
     *
     * @generated from protobuf field: double completion_percentage = 4
     */
    completion_percentage: number;
    /**
     * Last achievement completion time (across all games)
     *
     * @generated from protobuf field: optional uint64 last_achievement_at = 5
     */
    last_achievement_at?: bigint;
    /**
     * When the stats were first created
     *
     * @generated from protobuf field: uint64 created_at = 6
     */
    created_at: bigint;
    /**
     * When the stats were last updated
     *
     * @generated from protobuf field: uint64 updated_at = 7
     */
    updated_at: bigint;
}
/**
 * Achievement progression for a specific player and task
 *
 * @generated from protobuf message types.AchievementProgression
 */
export interface AchievementProgression {
    /**
     * Unique identifier (world:namespace:task_id:player_id)
     *
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * Achievement ID this task belongs to
     *
     * @generated from protobuf field: string achievement_id = 2
     */
    achievement_id: string;
    /**
     * Task ID
     *
     * @generated from protobuf field: string task_id = 3
     */
    task_id: string;
    /**
     * World address
     *
     * @generated from protobuf field: bytes world_address = 4
     */
    world_address: Uint8Array;
    /**
     * Namespace
     *
     * @generated from protobuf field: string namespace = 5
     */
    namespace: string;
    /**
     * Player address
     *
     * @generated from protobuf field: bytes player_id = 6
     */
    player_id: Uint8Array;
    /**
     * Current count/progress
     *
     * @generated from protobuf field: uint32 count = 7
     */
    count: number;
    /**
     * Is the task completed
     *
     * @generated from protobuf field: bool completed = 8
     */
    completed: boolean;
    /**
     * When the task was completed
     *
     * @generated from protobuf field: optional uint64 completed_at = 9
     */
    completed_at?: bigint;
    /**
     * When the progression was created
     *
     * @generated from protobuf field: uint64 created_at = 10
     */
    created_at: bigint;
    /**
     * When the progression was last updated
     *
     * @generated from protobuf field: uint64 updated_at = 11
     */
    updated_at: bigint;
}
/**
 * Query for achievements
 *
 * @generated from protobuf message types.AchievementQuery
 */
export interface AchievementQuery {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by hidden status (optional)
     *
     * @generated from protobuf field: optional bool hidden = 3
     */
    hidden?: boolean;
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * Query for player achievements
 *
 * @generated from protobuf message types.PlayerAchievementQuery
 */
export interface PlayerAchievementQuery {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 3
     */
    player_addresses: Uint8Array[];
    /**
     * Pagination
     *
     * @generated from protobuf field: types.Pagination pagination = 4
     */
    pagination?: Pagination;
}
/**
 * Player's progress on a specific achievement
 *
 * @generated from protobuf message types.PlayerAchievementProgress
 */
export interface PlayerAchievementProgress {
    /**
     * The achievement definition (includes task definitions)
     *
     * @generated from protobuf field: types.Achievement achievement = 1
     */
    achievement?: Achievement;
    /**
     * Progress on each task (references tasks by ID)
     *
     * @generated from protobuf field: repeated types.TaskProgress taskProgress = 2
     */
    taskProgress: TaskProgress[];
    /**
     * Is the achievement completed
     *
     * @generated from protobuf field: bool completed = 3
     */
    completed: boolean;
    /**
     * Progress percentage (0-100)
     *
     * @generated from protobuf field: double progress_percentage = 4
     */
    progress_percentage: number;
}
/**
 * Progress on a specific task (reference only, no duplication)
 *
 * @generated from protobuf message types.TaskProgress
 */
export interface TaskProgress {
    /**
     * Task ID reference (matches task_id in Achievement.tasks)
     *
     * @generated from protobuf field: string task_id = 1
     */
    task_id: string;
    /**
     * Current count
     *
     * @generated from protobuf field: uint32 count = 2
     */
    count: number;
    /**
     * Is the task completed
     *
     * @generated from protobuf field: bool completed = 3
     */
    completed: boolean;
}
/**
 * Player achievement entry (for a specific world/namespace/player combination)
 *
 * @generated from protobuf message types.PlayerAchievementEntry
 */
export interface PlayerAchievementEntry {
    /**
     * Player address (global identifier)
     *
     * @generated from protobuf field: bytes player_address = 1
     */
    player_address: Uint8Array;
    /**
     * Player's overall statistics (across all worlds/namespaces)
     *
     * @generated from protobuf field: types.PlayerAchievementStats stats = 2
     */
    stats?: PlayerAchievementStats;
    /**
     * Progress on each achievement (each achievement has its own world/namespace scope)
     *
     * @generated from protobuf field: repeated types.PlayerAchievementProgress achievements = 3
     */
    achievements: PlayerAchievementProgress[];
}
/**
 * @generated from protobuf enum types.PatternMatching
 */
export enum PatternMatching {
    /**
     * @generated from protobuf enum value: FixedLen = 0;
     */
    FixedLen = 0,
    /**
     * @generated from protobuf enum value: VariableLen = 1;
     */
    VariableLen = 1
}
/**
 * @generated from protobuf enum types.LogicalOperator
 */
export enum LogicalOperator {
    /**
     * @generated from protobuf enum value: AND = 0;
     */
    AND = 0,
    /**
     * @generated from protobuf enum value: OR = 1;
     */
    OR = 1
}
/**
 * @generated from protobuf enum types.ComparisonOperator
 */
export enum ComparisonOperator {
    /**
     * @generated from protobuf enum value: EQ = 0;
     */
    EQ = 0,
    /**
     * @generated from protobuf enum value: NEQ = 1;
     */
    NEQ = 1,
    /**
     * @generated from protobuf enum value: GT = 2;
     */
    GT = 2,
    /**
     * @generated from protobuf enum value: GTE = 3;
     */
    GTE = 3,
    /**
     * @generated from protobuf enum value: LT = 4;
     */
    LT = 4,
    /**
     * @generated from protobuf enum value: LTE = 5;
     */
    LTE = 5,
    /**
     * @generated from protobuf enum value: IN = 6;
     */
    IN = 6,
    /**
     * @generated from protobuf enum value: NOT_IN = 7;
     */
    NOT_IN = 7,
    /**
     * Array-specific operators
     *
     * Array contains value
     *
     * @generated from protobuf enum value: CONTAINS = 8;
     */
    CONTAINS = 8,
    /**
     * Array contains all values
     *
     * @generated from protobuf enum value: CONTAINS_ALL = 9;
     */
    CONTAINS_ALL = 9,
    /**
     * Array contains any of the values
     *
     * @generated from protobuf enum value: CONTAINS_ANY = 10;
     */
    CONTAINS_ANY = 10,
    /**
     * Array length equals
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_EQ = 11;
     */
    ARRAY_LENGTH_EQ = 11,
    /**
     * Array length greater than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_GT = 12;
     */
    ARRAY_LENGTH_GT = 12,
    /**
     * Array length less than
     *
     * @generated from protobuf enum value: ARRAY_LENGTH_LT = 13;
     */
    ARRAY_LENGTH_LT = 13
}
/**
 * @generated from protobuf enum types.OrderDirection
 */
export enum OrderDirection {
    /**
     * @generated from protobuf enum value: ASC = 0;
     */
    ASC = 0,
    /**
     * @generated from protobuf enum value: DESC = 1;
     */
    DESC = 1
}
/**
 * @generated from protobuf enum types.PaginationDirection
 */
export enum PaginationDirection {
    /**
     * @generated from protobuf enum value: FORWARD = 0;
     */
    FORWARD = 0,
    /**
     * @generated from protobuf enum value: BACKWARD = 1;
     */
    BACKWARD = 1
}
/**
 * @generated from protobuf enum types.CallType
 */
export enum CallType {
    /**
     * @generated from protobuf enum value: EXECUTE = 0;
     */
    EXECUTE = 0,
    /**
     * @generated from protobuf enum value: EXECUTE_FROM_OUTSIDE = 1;
     */
    EXECUTE_FROM_OUTSIDE = 1
}
/**
 * @generated from protobuf enum types.ContractType
 */
export enum ContractType {
    /**
     * @generated from protobuf enum value: WORLD = 0;
     */
    WORLD = 0,
    /**
     * @generated from protobuf enum value: ERC20 = 1;
     */
    ERC20 = 1,
    /**
     * @generated from protobuf enum value: ERC721 = 2;
     */
    ERC721 = 2,
    /**
     * @generated from protobuf enum value: ERC1155 = 3;
     */
    ERC1155 = 3,
    /**
     * @generated from protobuf enum value: UDC = 4;
     */
    UDC = 4,
    /**
     * @generated from protobuf enum value: OTHER = 5;
     */
    OTHER = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class World$Type extends MessageType<World> {
    constructor() {
        super("types.World", [
            { no: 1, name: "world_address", kind: "scalar", localName: "world_address", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Model }
        ]);
    }
    create(value?: PartialMessage<World>): World {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_address = "";
        message.models = [];
        if (value !== undefined)
            reflectionMergePartial<World>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: World): World {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string world_address */ 1:
                    message.world_address = reader.string();
                    break;
                case /* repeated types.Model models */ 2:
                    message.models.push(Model.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: World, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string world_address = 1; */
        if (message.world_address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.world_address);
        /* repeated types.Model models = 2; */
        for (let i = 0; i < message.models.length; i++)
            Model.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.World
 */
export const World = new World$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Model$Type extends MessageType<Model> {
    constructor() {
        super("types.Model", [
            { no: 1, name: "selector", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "packed_size", kind: "scalar", localName: "packed_size", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "unpacked_size", kind: "scalar", localName: "unpacked_size", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "class_hash", kind: "scalar", localName: "class_hash", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "layout", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "schema", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 9, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 10, name: "use_legacy_store", kind: "scalar", localName: "use_legacy_store", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Model>): Model {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.selector = new Uint8Array(0);
        message.namespace = "";
        message.name = "";
        message.packed_size = 0;
        message.unpacked_size = 0;
        message.class_hash = new Uint8Array(0);
        message.layout = new Uint8Array(0);
        message.schema = new Uint8Array(0);
        message.contract_address = new Uint8Array(0);
        message.use_legacy_store = false;
        message.world_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Model>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Model): Model {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes selector */ 1:
                    message.selector = reader.bytes();
                    break;
                case /* string namespace */ 2:
                    message.namespace = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* uint32 packed_size */ 4:
                    message.packed_size = reader.uint32();
                    break;
                case /* uint32 unpacked_size */ 5:
                    message.unpacked_size = reader.uint32();
                    break;
                case /* bytes class_hash */ 6:
                    message.class_hash = reader.bytes();
                    break;
                case /* bytes layout */ 7:
                    message.layout = reader.bytes();
                    break;
                case /* bytes schema */ 8:
                    message.schema = reader.bytes();
                    break;
                case /* bytes contract_address */ 9:
                    message.contract_address = reader.bytes();
                    break;
                case /* bool use_legacy_store */ 10:
                    message.use_legacy_store = reader.bool();
                    break;
                case /* bytes world_address */ 11:
                    message.world_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Model, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes selector = 1; */
        if (message.selector.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.selector);
        /* string namespace = 2; */
        if (message.namespace !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.namespace);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* uint32 packed_size = 4; */
        if (message.packed_size !== 0)
            writer.tag(4, WireType.Varint).uint32(message.packed_size);
        /* uint32 unpacked_size = 5; */
        if (message.unpacked_size !== 0)
            writer.tag(5, WireType.Varint).uint32(message.unpacked_size);
        /* bytes class_hash = 6; */
        if (message.class_hash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.class_hash);
        /* bytes layout = 7; */
        if (message.layout.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.layout);
        /* bytes schema = 8; */
        if (message.schema.length)
            writer.tag(8, WireType.LengthDelimited).bytes(message.schema);
        /* bytes contract_address = 9; */
        if (message.contract_address.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.contract_address);
        /* bool use_legacy_store = 10; */
        if (message.use_legacy_store !== false)
            writer.tag(10, WireType.Varint).bool(message.use_legacy_store);
        /* bytes world_address = 11; */
        if (message.world_address.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.world_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Model
 */
export const Model = new Model$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("types.Entity", [
            { no: 1, name: "hashed_keys", kind: "scalar", localName: "hashed_keys", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "models", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Struct },
            { no: 3, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "executed_at", kind: "scalar", localName: "executed_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashed_keys = new Uint8Array(0);
        message.models = [];
        message.created_at = 0n;
        message.updated_at = 0n;
        message.executed_at = 0n;
        message.world_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes hashed_keys */ 1:
                    message.hashed_keys = reader.bytes();
                    break;
                case /* repeated types.Struct models */ 2:
                    message.models.push(Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 created_at */ 3:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 4:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 executed_at */ 5:
                    message.executed_at = reader.uint64().toBigInt();
                    break;
                case /* bytes world_address */ 6:
                    message.world_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes hashed_keys = 1; */
        if (message.hashed_keys.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys);
        /* repeated types.Struct models = 2; */
        for (let i = 0; i < message.models.length; i++)
            Struct.internalBinaryWrite(message.models[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 3; */
        if (message.created_at !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 4; */
        if (message.updated_at !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.updated_at);
        /* uint64 executed_at = 5; */
        if (message.executed_at !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.executed_at);
        /* bytes world_address = 6; */
        if (message.world_address.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.world_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super("types.Event", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "transaction_hash", kind: "scalar", localName: "transaction_hash", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.data = [];
        message.transaction_hash = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Event): Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes keys */ 1:
                    message.keys.push(reader.bytes());
                    break;
                case /* repeated bytes data */ 2:
                    message.data.push(reader.bytes());
                    break;
                case /* bytes transaction_hash */ 3:
                    message.transaction_hash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keys[i]);
        /* repeated bytes data = 2; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data[i]);
        /* bytes transaction_hash = 3; */
        if (message.transaction_hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.transaction_hash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Event
 */
export const Event = new Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Query$Type extends MessageType<Query> {
    constructor() {
        super("types.Query", [
            { no: 1, name: "clause", kind: "message", T: () => Clause },
            { no: 2, name: "no_hashed_keys", kind: "scalar", localName: "no_hashed_keys", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "models", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination },
            { no: 5, name: "historical", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Query>): Query {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.no_hashed_keys = false;
        message.models = [];
        message.historical = false;
        message.world_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<Query>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Query): Query {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                case /* bool no_hashed_keys */ 2:
                    message.no_hashed_keys = reader.bool();
                    break;
                case /* repeated string models */ 3:
                    message.models.push(reader.string());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                case /* bool historical */ 5:
                    message.historical = reader.bool();
                    break;
                case /* repeated bytes world_addresses */ 6:
                    message.world_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Query, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool no_hashed_keys = 2; */
        if (message.no_hashed_keys !== false)
            writer.tag(2, WireType.Varint).bool(message.no_hashed_keys);
        /* repeated string models = 3; */
        for (let i = 0; i < message.models.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.models[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool historical = 5; */
        if (message.historical !== false)
            writer.tag(5, WireType.Varint).bool(message.historical);
        /* repeated bytes world_addresses = 6; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(6, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Query
 */
export const Query = new Query$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventQuery$Type extends MessageType<EventQuery> {
    constructor() {
        super("types.EventQuery", [
            { no: 1, name: "keys", kind: "message", T: () => KeysClause },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<EventQuery>): EventQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventQuery): EventQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.KeysClause keys */ 1:
                    message.keys = KeysClause.internalBinaryRead(reader, reader.uint32(), options, message.keys);
                    break;
                case /* types.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.KeysClause keys = 1; */
        if (message.keys)
            KeysClause.internalBinaryWrite(message.keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.EventQuery
 */
export const EventQuery = new EventQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Clause$Type extends MessageType<Clause> {
    constructor() {
        super("types.Clause", [
            { no: 1, name: "hashed_keys", kind: "message", localName: "hashed_keys", oneof: "clause_type", T: () => HashedKeysClause },
            { no: 2, name: "keys", kind: "message", oneof: "clause_type", T: () => KeysClause },
            { no: 3, name: "member", kind: "message", oneof: "clause_type", T: () => MemberClause },
            { no: 4, name: "composite", kind: "message", oneof: "clause_type", T: () => CompositeClause }
        ]);
    }
    create(value?: PartialMessage<Clause>): Clause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clause_type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Clause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clause): Clause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.HashedKeysClause hashed_keys */ 1:
                    message.clause_type = {
                        oneofKind: "hashed_keys",
                        hashed_keys: HashedKeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).hashed_keys)
                    };
                    break;
                case /* types.KeysClause keys */ 2:
                    message.clause_type = {
                        oneofKind: "keys",
                        keys: KeysClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).keys)
                    };
                    break;
                case /* types.MemberClause member */ 3:
                    message.clause_type = {
                        oneofKind: "member",
                        member: MemberClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).member)
                    };
                    break;
                case /* types.CompositeClause composite */ 4:
                    message.clause_type = {
                        oneofKind: "composite",
                        composite: CompositeClause.internalBinaryRead(reader, reader.uint32(), options, (message.clause_type as any).composite)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Clause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.HashedKeysClause hashed_keys = 1; */
        if (message.clause_type.oneofKind === "hashed_keys")
            HashedKeysClause.internalBinaryWrite(message.clause_type.hashed_keys, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.KeysClause keys = 2; */
        if (message.clause_type.oneofKind === "keys")
            KeysClause.internalBinaryWrite(message.clause_type.keys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* types.MemberClause member = 3; */
        if (message.clause_type.oneofKind === "member")
            MemberClause.internalBinaryWrite(message.clause_type.member, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.CompositeClause composite = 4; */
        if (message.clause_type.oneofKind === "composite")
            CompositeClause.internalBinaryWrite(message.clause_type.composite, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Clause
 */
export const Clause = new Clause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeysClause$Type extends MessageType<KeysClause> {
    constructor() {
        super("types.KeysClause", [
            { no: 2, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pattern_matching", kind: "enum", localName: "pattern_matching", T: () => ["types.PatternMatching", PatternMatching] },
            { no: 4, name: "models", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<KeysClause>): KeysClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        message.pattern_matching = 0;
        message.models = [];
        if (value !== undefined)
            reflectionMergePartial<KeysClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeysClause): KeysClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes keys */ 2:
                    message.keys.push(reader.bytes());
                    break;
                case /* types.PatternMatching pattern_matching */ 3:
                    message.pattern_matching = reader.int32();
                    break;
                case /* repeated string models */ 4:
                    message.models.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes keys = 2; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.keys[i]);
        /* types.PatternMatching pattern_matching = 3; */
        if (message.pattern_matching !== 0)
            writer.tag(3, WireType.Varint).int32(message.pattern_matching);
        /* repeated string models = 4; */
        for (let i = 0; i < message.models.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.models[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.KeysClause
 */
export const KeysClause = new KeysClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HashedKeysClause$Type extends MessageType<HashedKeysClause> {
    constructor() {
        super("types.HashedKeysClause", [
            { no: 1, name: "hashed_keys", kind: "scalar", localName: "hashed_keys", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<HashedKeysClause>): HashedKeysClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.hashed_keys = [];
        if (value !== undefined)
            reflectionMergePartial<HashedKeysClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HashedKeysClause): HashedKeysClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes hashed_keys */ 1:
                    message.hashed_keys.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HashedKeysClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes hashed_keys = 1; */
        for (let i = 0; i < message.hashed_keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.hashed_keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.HashedKeysClause
 */
export const HashedKeysClause = new HashedKeysClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberValue$Type extends MessageType<MemberValue> {
    constructor() {
        super("types.MemberValue", [
            { no: 1, name: "primitive", kind: "message", oneof: "value_type", T: () => Primitive },
            { no: 2, name: "string", kind: "scalar", oneof: "value_type", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "list", kind: "message", oneof: "value_type", T: () => MemberValueList }
        ]);
    }
    create(value?: PartialMessage<MemberValue>): MemberValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value_type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MemberValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValue): MemberValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Primitive primitive */ 1:
                    message.value_type = {
                        oneofKind: "primitive",
                        primitive: Primitive.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).primitive)
                    };
                    break;
                case /* string string */ 2:
                    message.value_type = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                case /* types.MemberValueList list */ 3:
                    message.value_type = {
                        oneofKind: "list",
                        list: MemberValueList.internalBinaryRead(reader, reader.uint32(), options, (message.value_type as any).list)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Primitive primitive = 1; */
        if (message.value_type.oneofKind === "primitive")
            Primitive.internalBinaryWrite(message.value_type.primitive, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string string = 2; */
        if (message.value_type.oneofKind === "string")
            writer.tag(2, WireType.LengthDelimited).string(message.value_type.string);
        /* types.MemberValueList list = 3; */
        if (message.value_type.oneofKind === "list")
            MemberValueList.internalBinaryWrite(message.value_type.list, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberValue
 */
export const MemberValue = new MemberValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberValueList$Type extends MessageType<MemberValueList> {
    constructor() {
        super("types.MemberValueList", [
            { no: 1, name: "values", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MemberValue }
        ]);
    }
    create(value?: PartialMessage<MemberValueList>): MemberValueList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.values = [];
        if (value !== undefined)
            reflectionMergePartial<MemberValueList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberValueList): MemberValueList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.MemberValue values */ 1:
                    message.values.push(MemberValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberValueList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.MemberValue values = 1; */
        for (let i = 0; i < message.values.length; i++)
            MemberValue.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberValueList
 */
export const MemberValueList = new MemberValueList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MemberClause$Type extends MessageType<MemberClause> {
    constructor() {
        super("types.MemberClause", [
            { no: 2, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "member", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "operator", kind: "enum", T: () => ["types.ComparisonOperator", ComparisonOperator] },
            { no: 5, name: "value", kind: "message", T: () => MemberValue }
        ]);
    }
    create(value?: PartialMessage<MemberClause>): MemberClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.model = "";
        message.member = "";
        message.operator = 0;
        if (value !== undefined)
            reflectionMergePartial<MemberClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MemberClause): MemberClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string model */ 2:
                    message.model = reader.string();
                    break;
                case /* string member */ 3:
                    message.member = reader.string();
                    break;
                case /* types.ComparisonOperator operator */ 4:
                    message.operator = reader.int32();
                    break;
                case /* types.MemberValue value */ 5:
                    message.value = MemberValue.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MemberClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string model = 2; */
        if (message.model !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.model);
        /* string member = 3; */
        if (message.member !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.member);
        /* types.ComparisonOperator operator = 4; */
        if (message.operator !== 0)
            writer.tag(4, WireType.Varint).int32(message.operator);
        /* types.MemberValue value = 5; */
        if (message.value)
            MemberValue.internalBinaryWrite(message.value, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.MemberClause
 */
export const MemberClause = new MemberClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CompositeClause$Type extends MessageType<CompositeClause> {
    constructor() {
        super("types.CompositeClause", [
            { no: 3, name: "operator", kind: "enum", T: () => ["types.LogicalOperator", LogicalOperator] },
            { no: 4, name: "clauses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<CompositeClause>): CompositeClause {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.operator = 0;
        message.clauses = [];
        if (value !== undefined)
            reflectionMergePartial<CompositeClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CompositeClause): CompositeClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.LogicalOperator operator */ 3:
                    message.operator = reader.int32();
                    break;
                case /* repeated types.Clause clauses */ 4:
                    message.clauses.push(Clause.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CompositeClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.LogicalOperator operator = 3; */
        if (message.operator !== 0)
            writer.tag(3, WireType.Varint).int32(message.operator);
        /* repeated types.Clause clauses = 4; */
        for (let i = 0; i < message.clauses.length; i++)
            Clause.internalBinaryWrite(message.clauses[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.CompositeClause
 */
export const CompositeClause = new CompositeClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Token$Type extends MessageType<Token> {
    constructor() {
        super("types.Token", [
            { no: 1, name: "token_id", kind: "scalar", localName: "token_id", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "total_supply", kind: "scalar", localName: "total_supply", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Token>): Token {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.name = "";
        message.symbol = "";
        message.decimals = 0;
        message.metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Token): Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes token_id */ 1:
                    message.token_id = reader.bytes();
                    break;
                case /* bytes contract_address */ 2:
                    message.contract_address = reader.bytes();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 4:
                    message.symbol = reader.string();
                    break;
                case /* uint32 decimals */ 5:
                    message.decimals = reader.uint32();
                    break;
                case /* bytes metadata */ 6:
                    message.metadata = reader.bytes();
                    break;
                case /* optional bytes total_supply */ 7:
                    message.total_supply = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes token_id = 1; */
        if (message.token_id !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.token_id);
        /* bytes contract_address = 2; */
        if (message.contract_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string symbol = 4; */
        if (message.symbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.symbol);
        /* uint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).uint32(message.decimals);
        /* bytes metadata = 6; */
        if (message.metadata.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.metadata);
        /* optional bytes total_supply = 7; */
        if (message.total_supply !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.total_supply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Token
 */
export const Token = new Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenBalance$Type extends MessageType<TokenBalance> {
    constructor() {
        super("types.TokenBalance", [
            { no: 1, name: "balance", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "account_address", kind: "scalar", localName: "account_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_id", kind: "scalar", localName: "token_id", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenBalance>): TokenBalance {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.balance = new Uint8Array(0);
        message.account_address = new Uint8Array(0);
        message.contract_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TokenBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalance): TokenBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes balance */ 1:
                    message.balance = reader.bytes();
                    break;
                case /* bytes account_address */ 2:
                    message.account_address = reader.bytes();
                    break;
                case /* bytes contract_address */ 3:
                    message.contract_address = reader.bytes();
                    break;
                case /* optional bytes token_id */ 4:
                    message.token_id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes balance = 1; */
        if (message.balance.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.balance);
        /* bytes account_address = 2; */
        if (message.account_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.account_address);
        /* bytes contract_address = 3; */
        if (message.contract_address.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_address);
        /* optional bytes token_id = 4; */
        if (message.token_id !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenBalance
 */
export const TokenBalance = new TokenBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderBy$Type extends MessageType<OrderBy> {
    constructor() {
        super("types.OrderBy", [
            { no: 1, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "direction", kind: "enum", T: () => ["types.OrderDirection", OrderDirection] }
        ]);
    }
    create(value?: PartialMessage<OrderBy>): OrderBy {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.field = "";
        message.direction = 0;
        if (value !== undefined)
            reflectionMergePartial<OrderBy>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderBy): OrderBy {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string field */ 1:
                    message.field = reader.string();
                    break;
                case /* types.OrderDirection direction */ 2:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderBy, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string field = 1; */
        if (message.field !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.field);
        /* types.OrderDirection direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.OrderBy
 */
export const OrderBy = new OrderBy$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Controller$Type extends MessageType<Controller> {
    constructor() {
        super("types.Controller", [
            { no: 1, name: "address", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "deployed_at_timestamp", kind: "scalar", localName: "deployed_at_timestamp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Controller>): Controller {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = new Uint8Array(0);
        message.username = "";
        message.deployed_at_timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Controller>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Controller): Controller {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes address */ 1:
                    message.address = reader.bytes();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* uint64 deployed_at_timestamp */ 3:
                    message.deployed_at_timestamp = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Controller, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes address = 1; */
        if (message.address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.address);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* uint64 deployed_at_timestamp = 3; */
        if (message.deployed_at_timestamp !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.deployed_at_timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Controller
 */
export const Controller = new Controller$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Pagination$Type extends MessageType<Pagination> {
    constructor() {
        super("types.Pagination", [
            { no: 1, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "direction", kind: "enum", T: () => ["types.PaginationDirection", PaginationDirection] },
            { no: 4, name: "order_by", kind: "message", localName: "order_by", repeat: 2 /*RepeatType.UNPACKED*/, T: () => OrderBy }
        ]);
    }
    create(value?: PartialMessage<Pagination>): Pagination {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cursor = "";
        message.limit = 0;
        message.direction = 0;
        message.order_by = [];
        if (value !== undefined)
            reflectionMergePartial<Pagination>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Pagination): Pagination {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cursor */ 1:
                    message.cursor = reader.string();
                    break;
                case /* uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                case /* types.PaginationDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                case /* repeated types.OrderBy order_by */ 4:
                    message.order_by.push(OrderBy.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Pagination, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cursor = 1; */
        if (message.cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cursor);
        /* uint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        /* types.PaginationDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        /* repeated types.OrderBy order_by = 4; */
        for (let i = 0; i < message.order_by.length; i++)
            OrderBy.internalBinaryWrite(message.order_by[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Pagination
 */
export const Pagination = new Pagination$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ControllerQuery$Type extends MessageType<ControllerQuery> {
    constructor() {
        super("types.ControllerQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "usernames", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<ControllerQuery>): ControllerQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.usernames = [];
        if (value !== undefined)
            reflectionMergePartial<ControllerQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ControllerQuery): ControllerQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated string usernames */ 2:
                    message.usernames.push(reader.string());
                    break;
                case /* types.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ControllerQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated string usernames = 2; */
        for (let i = 0; i < message.usernames.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.usernames[i]);
        /* types.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ControllerQuery
 */
export const ControllerQuery = new ControllerQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenAttributeFilter$Type extends MessageType<TokenAttributeFilter> {
    constructor() {
        super("types.TokenAttributeFilter", [
            { no: 1, name: "trait_name", kind: "scalar", localName: "trait_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "trait_value", kind: "scalar", localName: "trait_value", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenAttributeFilter>): TokenAttributeFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trait_name = "";
        message.trait_value = "";
        if (value !== undefined)
            reflectionMergePartial<TokenAttributeFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenAttributeFilter): TokenAttributeFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trait_name */ 1:
                    message.trait_name = reader.string();
                    break;
                case /* string trait_value */ 2:
                    message.trait_value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenAttributeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trait_name = 1; */
        if (message.trait_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.trait_name);
        /* string trait_value = 2; */
        if (message.trait_value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.trait_value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenAttributeFilter
 */
export const TokenAttributeFilter = new TokenAttributeFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenQuery$Type extends MessageType<TokenQuery> {
    constructor() {
        super("types.TokenQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "attribute_filters", kind: "message", localName: "attribute_filters", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenAttributeFilter },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenQuery>): TokenQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.token_ids = [];
        message.attribute_filters = [];
        if (value !== undefined)
            reflectionMergePartial<TokenQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenQuery): TokenQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 2:
                    message.token_ids.push(reader.bytes());
                    break;
                case /* repeated types.TokenAttributeFilter attribute_filters */ 3:
                    message.attribute_filters.push(TokenAttributeFilter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 2; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
        /* repeated types.TokenAttributeFilter attribute_filters = 3; */
        for (let i = 0; i < message.attribute_filters.length; i++)
            TokenAttributeFilter.internalBinaryWrite(message.attribute_filters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenQuery
 */
export const TokenQuery = new TokenQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenBalanceQuery$Type extends MessageType<TokenBalanceQuery> {
    constructor() {
        super("types.TokenBalanceQuery", [
            { no: 1, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenBalanceQuery>): TokenBalanceQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<TokenBalanceQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenBalanceQuery): TokenBalanceQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenBalanceQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenBalanceQuery
 */
export const TokenBalanceQuery = new TokenBalanceQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenContractQuery$Type extends MessageType<TokenContractQuery> {
    constructor() {
        super("types.TokenContractQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1 /*RepeatType.PACKED*/, T: () => ["types.ContractType", ContractType] },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenContractQuery>): TokenContractQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.contract_types = [];
        if (value !== undefined)
            reflectionMergePartial<TokenContractQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContractQuery): TokenContractQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated types.ContractType contract_types */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.contract_types.push(reader.int32());
                    else
                        message.contract_types.push(reader.int32());
                    break;
                case /* types.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated types.ContractType contract_types = 2; */
        if (message.contract_types.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.contract_types.length; i++)
                writer.int32(message.contract_types[i]);
            writer.join();
        }
        /* types.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenContractQuery
 */
export const TokenContractQuery = new TokenContractQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenTransfer$Type extends MessageType<TokenTransfer> {
    constructor() {
        super("types.TokenTransfer", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "from_address", kind: "scalar", localName: "from_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "to_address", kind: "scalar", localName: "to_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "amount", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "token_id", kind: "scalar", localName: "token_id", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "executed_at", kind: "scalar", localName: "executed_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "event_id", kind: "scalar", localName: "event_id", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TokenTransfer>): TokenTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.contract_address = new Uint8Array(0);
        message.from_address = new Uint8Array(0);
        message.to_address = new Uint8Array(0);
        message.amount = new Uint8Array(0);
        message.executed_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<TokenTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTransfer): TokenTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes contract_address */ 2:
                    message.contract_address = reader.bytes();
                    break;
                case /* bytes from_address */ 3:
                    message.from_address = reader.bytes();
                    break;
                case /* bytes to_address */ 4:
                    message.to_address = reader.bytes();
                    break;
                case /* bytes amount */ 5:
                    message.amount = reader.bytes();
                    break;
                case /* optional bytes token_id */ 6:
                    message.token_id = reader.bytes();
                    break;
                case /* uint64 executed_at */ 7:
                    message.executed_at = reader.uint64().toBigInt();
                    break;
                case /* optional string event_id */ 8:
                    message.event_id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes contract_address = 2; */
        if (message.contract_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_address);
        /* bytes from_address = 3; */
        if (message.from_address.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.from_address);
        /* bytes to_address = 4; */
        if (message.to_address.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.to_address);
        /* bytes amount = 5; */
        if (message.amount.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.amount);
        /* optional bytes token_id = 6; */
        if (message.token_id !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.token_id);
        /* uint64 executed_at = 7; */
        if (message.executed_at !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.executed_at);
        /* optional string event_id = 8; */
        if (message.event_id !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.event_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenTransfer
 */
export const TokenTransfer = new TokenTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenTransferQuery$Type extends MessageType<TokenTransferQuery> {
    constructor() {
        super("types.TokenTransferQuery", [
            { no: 1, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TokenTransferQuery>): TokenTransferQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<TokenTransferQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenTransferQuery): TokenTransferQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenTransferQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenTransferQuery
 */
export const TokenTransferQuery = new TokenTransferQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionCall$Type extends MessageType<TransactionCall> {
    constructor() {
        super("types.TransactionCall", [
            { no: 1, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "entrypoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "calldata", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "call_type", kind: "enum", localName: "call_type", T: () => ["types.CallType", CallType] },
            { no: 5, name: "caller_address", kind: "scalar", localName: "caller_address", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionCall>): TransactionCall {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.entrypoint = "";
        message.calldata = [];
        message.call_type = 0;
        message.caller_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TransactionCall>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionCall): TransactionCall {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                case /* string entrypoint */ 2:
                    message.entrypoint = reader.string();
                    break;
                case /* repeated bytes calldata */ 3:
                    message.calldata.push(reader.bytes());
                    break;
                case /* types.CallType call_type */ 4:
                    message.call_type = reader.int32();
                    break;
                case /* bytes caller_address */ 5:
                    message.caller_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionCall, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
        /* string entrypoint = 2; */
        if (message.entrypoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.entrypoint);
        /* repeated bytes calldata = 3; */
        for (let i = 0; i < message.calldata.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
        /* types.CallType call_type = 4; */
        if (message.call_type !== 0)
            writer.tag(4, WireType.Varint).int32(message.call_type);
        /* bytes caller_address = 5; */
        if (message.caller_address.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.caller_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionCall
 */
export const TransactionCall = new TransactionCall$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("types.Transaction", [
            { no: 1, name: "transaction_hash", kind: "scalar", localName: "transaction_hash", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sender_address", kind: "scalar", localName: "sender_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "calldata", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "max_fee", kind: "scalar", localName: "max_fee", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "signature", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "nonce", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "block_number", kind: "scalar", localName: "block_number", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "transaction_type", kind: "scalar", localName: "transaction_type", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "block_timestamp", kind: "scalar", localName: "block_timestamp", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "calls", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TransactionCall },
            { no: 11, name: "unique_models", kind: "scalar", localName: "unique_models", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transaction_hash = new Uint8Array(0);
        message.sender_address = new Uint8Array(0);
        message.calldata = [];
        message.max_fee = new Uint8Array(0);
        message.signature = [];
        message.nonce = new Uint8Array(0);
        message.block_number = 0n;
        message.transaction_type = "";
        message.block_timestamp = 0n;
        message.calls = [];
        message.unique_models = [];
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes transaction_hash */ 1:
                    message.transaction_hash = reader.bytes();
                    break;
                case /* bytes sender_address */ 2:
                    message.sender_address = reader.bytes();
                    break;
                case /* repeated bytes calldata */ 3:
                    message.calldata.push(reader.bytes());
                    break;
                case /* bytes max_fee */ 4:
                    message.max_fee = reader.bytes();
                    break;
                case /* repeated bytes signature */ 5:
                    message.signature.push(reader.bytes());
                    break;
                case /* bytes nonce */ 6:
                    message.nonce = reader.bytes();
                    break;
                case /* uint64 block_number */ 7:
                    message.block_number = reader.uint64().toBigInt();
                    break;
                case /* string transaction_type */ 8:
                    message.transaction_type = reader.string();
                    break;
                case /* uint64 block_timestamp */ 9:
                    message.block_timestamp = reader.uint64().toBigInt();
                    break;
                case /* repeated types.TransactionCall calls */ 10:
                    message.calls.push(TransactionCall.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated bytes unique_models */ 11:
                    message.unique_models.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes transaction_hash = 1; */
        if (message.transaction_hash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hash);
        /* bytes sender_address = 2; */
        if (message.sender_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sender_address);
        /* repeated bytes calldata = 3; */
        for (let i = 0; i < message.calldata.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.calldata[i]);
        /* bytes max_fee = 4; */
        if (message.max_fee.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.max_fee);
        /* repeated bytes signature = 5; */
        for (let i = 0; i < message.signature.length; i++)
            writer.tag(5, WireType.LengthDelimited).bytes(message.signature[i]);
        /* bytes nonce = 6; */
        if (message.nonce.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.nonce);
        /* uint64 block_number = 7; */
        if (message.block_number !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.block_number);
        /* string transaction_type = 8; */
        if (message.transaction_type !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.transaction_type);
        /* uint64 block_timestamp = 9; */
        if (message.block_timestamp !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.block_timestamp);
        /* repeated types.TransactionCall calls = 10; */
        for (let i = 0; i < message.calls.length; i++)
            TransactionCall.internalBinaryWrite(message.calls[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes unique_models = 11; */
        for (let i = 0; i < message.unique_models.length; i++)
            writer.tag(11, WireType.LengthDelimited).bytes(message.unique_models[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionFilter$Type extends MessageType<TransactionFilter> {
    constructor() {
        super("types.TransactionFilter", [
            { no: 1, name: "transaction_hashes", kind: "scalar", localName: "transaction_hashes", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "caller_addresses", kind: "scalar", localName: "caller_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "entrypoints", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "model_selectors", kind: "scalar", localName: "model_selectors", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "from_block", kind: "scalar", localName: "from_block", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "to_block", kind: "scalar", localName: "to_block", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionFilter>): TransactionFilter {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.transaction_hashes = [];
        message.caller_addresses = [];
        message.contract_addresses = [];
        message.entrypoints = [];
        message.model_selectors = [];
        if (value !== undefined)
            reflectionMergePartial<TransactionFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionFilter): TransactionFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes transaction_hashes */ 1:
                    message.transaction_hashes.push(reader.bytes());
                    break;
                case /* repeated bytes caller_addresses */ 2:
                    message.caller_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 3:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated string entrypoints */ 4:
                    message.entrypoints.push(reader.string());
                    break;
                case /* repeated bytes model_selectors */ 5:
                    message.model_selectors.push(reader.bytes());
                    break;
                case /* optional uint64 from_block */ 6:
                    message.from_block = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 to_block */ 7:
                    message.to_block = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes transaction_hashes = 1; */
        for (let i = 0; i < message.transaction_hashes.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction_hashes[i]);
        /* repeated bytes caller_addresses = 2; */
        for (let i = 0; i < message.caller_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
        /* repeated bytes contract_addresses = 3; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated string entrypoints = 4; */
        for (let i = 0; i < message.entrypoints.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.entrypoints[i]);
        /* repeated bytes model_selectors = 5; */
        for (let i = 0; i < message.model_selectors.length; i++)
            writer.tag(5, WireType.LengthDelimited).bytes(message.model_selectors[i]);
        /* optional uint64 from_block = 6; */
        if (message.from_block !== undefined)
            writer.tag(6, WireType.Varint).uint64(message.from_block);
        /* optional uint64 to_block = 7; */
        if (message.to_block !== undefined)
            writer.tag(7, WireType.Varint).uint64(message.to_block);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionFilter
 */
export const TransactionFilter = new TransactionFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionQuery$Type extends MessageType<TransactionQuery> {
    constructor() {
        super("types.TransactionQuery", [
            { no: 1, name: "filter", kind: "message", T: () => TransactionFilter },
            { no: 2, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<TransactionQuery>): TransactionQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TransactionQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionQuery): TransactionQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* types.Pagination pagination */ 2:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* types.Pagination pagination = 2; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TransactionQuery
 */
export const TransactionQuery = new TransactionQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Activity$Type extends MessageType<Activity> {
    constructor() {
        super("types.Activity", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "caller_address", kind: "scalar", localName: "caller_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "session_start", kind: "scalar", localName: "session_start", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "session_end", kind: "scalar", localName: "session_end", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "action_count", kind: "scalar", localName: "action_count", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "actions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ } },
            { no: 9, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Activity>): Activity {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.world_address = new Uint8Array(0);
        message.namespace = "";
        message.caller_address = new Uint8Array(0);
        message.session_start = 0n;
        message.session_end = 0n;
        message.action_count = 0;
        message.actions = {};
        message.updated_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<Activity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Activity): Activity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes world_address */ 2:
                    message.world_address = reader.bytes();
                    break;
                case /* string namespace */ 3:
                    message.namespace = reader.string();
                    break;
                case /* bytes caller_address */ 4:
                    message.caller_address = reader.bytes();
                    break;
                case /* uint64 session_start */ 5:
                    message.session_start = reader.uint64().toBigInt();
                    break;
                case /* uint64 session_end */ 6:
                    message.session_end = reader.uint64().toBigInt();
                    break;
                case /* uint32 action_count */ 7:
                    message.action_count = reader.uint32();
                    break;
                case /* map<string, uint32> actions */ 8:
                    this.binaryReadMap8(message.actions, reader, options);
                    break;
                case /* uint64 updated_at */ 9:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap8(map: Activity["actions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Activity["actions"] | undefined, val: Activity["actions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for types.Activity.actions");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Activity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes world_address = 2; */
        if (message.world_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.world_address);
        /* string namespace = 3; */
        if (message.namespace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.namespace);
        /* bytes caller_address = 4; */
        if (message.caller_address.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.caller_address);
        /* uint64 session_start = 5; */
        if (message.session_start !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.session_start);
        /* uint64 session_end = 6; */
        if (message.session_end !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.session_end);
        /* uint32 action_count = 7; */
        if (message.action_count !== 0)
            writer.tag(7, WireType.Varint).uint32(message.action_count);
        /* map<string, uint32> actions = 8; */
        for (let k of globalThis.Object.keys(message.actions))
            writer.tag(8, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint32(message.actions[k]).join();
        /* uint64 updated_at = 9; */
        if (message.updated_at !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Activity
 */
export const Activity = new Activity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivityQuery$Type extends MessageType<ActivityQuery> {
    constructor() {
        super("types.ActivityQuery", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "caller_addresses", kind: "scalar", localName: "caller_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "from_time", kind: "scalar", localName: "from_time", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "to_time", kind: "scalar", localName: "to_time", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<ActivityQuery>): ActivityQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        message.namespaces = [];
        message.caller_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<ActivityQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivityQuery): ActivityQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes caller_addresses */ 3:
                    message.caller_addresses.push(reader.bytes());
                    break;
                case /* optional uint64 from_time */ 4:
                    message.from_time = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 to_time */ 5:
                    message.to_time = reader.uint64().toBigInt();
                    break;
                case /* types.Pagination pagination */ 6:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivityQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 2; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes caller_addresses = 3; */
        for (let i = 0; i < message.caller_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
        /* optional uint64 from_time = 4; */
        if (message.from_time !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.from_time);
        /* optional uint64 to_time = 5; */
        if (message.to_time !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.to_time);
        /* types.Pagination pagination = 6; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ActivityQuery
 */
export const ActivityQuery = new ActivityQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlValue$Type extends MessageType<SqlValue> {
    constructor() {
        super("types.SqlValue", [
            { no: 1, name: "text", kind: "scalar", oneof: "value_type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "integer", kind: "scalar", oneof: "value_type", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "real", kind: "scalar", oneof: "value_type", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "blob", kind: "scalar", oneof: "value_type", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "null", kind: "scalar", oneof: "value_type", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SqlValue>): SqlValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value_type = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SqlValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlValue): SqlValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.value_type = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* int64 integer */ 2:
                    message.value_type = {
                        oneofKind: "integer",
                        integer: reader.int64().toBigInt()
                    };
                    break;
                case /* double real */ 3:
                    message.value_type = {
                        oneofKind: "real",
                        real: reader.double()
                    };
                    break;
                case /* bytes blob */ 4:
                    message.value_type = {
                        oneofKind: "blob",
                        blob: reader.bytes()
                    };
                    break;
                case /* bool null */ 5:
                    message.value_type = {
                        oneofKind: "null",
                        null: reader.bool()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.value_type.oneofKind === "text")
            writer.tag(1, WireType.LengthDelimited).string(message.value_type.text);
        /* int64 integer = 2; */
        if (message.value_type.oneofKind === "integer")
            writer.tag(2, WireType.Varint).int64(message.value_type.integer);
        /* double real = 3; */
        if (message.value_type.oneofKind === "real")
            writer.tag(3, WireType.Bit64).double(message.value_type.real);
        /* bytes blob = 4; */
        if (message.value_type.oneofKind === "blob")
            writer.tag(4, WireType.LengthDelimited).bytes(message.value_type.blob);
        /* bool null = 5; */
        if (message.value_type.oneofKind === "null")
            writer.tag(5, WireType.Varint).bool(message.value_type.null);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SqlValue
 */
export const SqlValue = new SqlValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlRow$Type extends MessageType<SqlRow> {
    constructor() {
        super("types.SqlRow", [
            { no: 1, name: "fields", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => SqlValue } }
        ]);
    }
    create(value?: PartialMessage<SqlRow>): SqlRow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = {};
        if (value !== undefined)
            reflectionMergePartial<SqlRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlRow): SqlRow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, types.SqlValue> fields */ 1:
                    this.binaryReadMap1(message.fields, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SqlRow["fields"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SqlRow["fields"] | undefined, val: SqlRow["fields"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = SqlValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for types.SqlRow.fields");
            }
        }
        map[key ?? ""] = val ?? SqlValue.create();
    }
    internalBinaryWrite(message: SqlRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, types.SqlValue> fields = 1; */
        for (let k of globalThis.Object.keys(message.fields)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            SqlValue.internalBinaryWrite(message.fields[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SqlRow
 */
export const SqlRow = new SqlRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlQueryRequest$Type extends MessageType<SqlQueryRequest> {
    constructor() {
        super("types.SqlQueryRequest", [
            { no: 1, name: "query", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SqlQueryRequest>): SqlQueryRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.query = "";
        if (value !== undefined)
            reflectionMergePartial<SqlQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlQueryRequest): SqlQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string query */ 1:
                    message.query = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string query = 1; */
        if (message.query !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.query);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SqlQueryRequest
 */
export const SqlQueryRequest = new SqlQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SqlQueryResponse$Type extends MessageType<SqlQueryResponse> {
    constructor() {
        super("types.SqlQueryResponse", [
            { no: 1, name: "rows", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SqlRow }
        ]);
    }
    create(value?: PartialMessage<SqlQueryResponse>): SqlQueryResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rows = [];
        if (value !== undefined)
            reflectionMergePartial<SqlQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SqlQueryResponse): SqlQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.SqlRow rows */ 1:
                    message.rows.push(SqlRow.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SqlQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.SqlRow rows = 1; */
        for (let i = 0; i < message.rows.length; i++)
            SqlRow.internalBinaryWrite(message.rows[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.SqlQueryResponse
 */
export const SqlQueryResponse = new SqlQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Contract$Type extends MessageType<Contract> {
    constructor() {
        super("types.Contract", [
            { no: 1, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
            { no: 3, name: "head", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "tps", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "last_block_timestamp", kind: "scalar", localName: "last_block_timestamp", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "last_pending_block_tx", kind: "scalar", localName: "last_pending_block_tx", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Contract>): Contract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.contract_type = 0;
        message.updated_at = 0n;
        message.created_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<Contract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Contract): Contract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                case /* types.ContractType contract_type */ 2:
                    message.contract_type = reader.int32();
                    break;
                case /* optional uint64 head */ 3:
                    message.head = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 tps */ 4:
                    message.tps = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 last_block_timestamp */ 5:
                    message.last_block_timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional bytes last_pending_block_tx */ 6:
                    message.last_pending_block_tx = reader.bytes();
                    break;
                case /* uint64 updated_at */ 7:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_at */ 8:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Contract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
        /* types.ContractType contract_type = 2; */
        if (message.contract_type !== 0)
            writer.tag(2, WireType.Varint).int32(message.contract_type);
        /* optional uint64 head = 3; */
        if (message.head !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.head);
        /* optional uint64 tps = 4; */
        if (message.tps !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.tps);
        /* optional uint64 last_block_timestamp = 5; */
        if (message.last_block_timestamp !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.last_block_timestamp);
        /* optional bytes last_pending_block_tx = 6; */
        if (message.last_pending_block_tx !== undefined)
            writer.tag(6, WireType.LengthDelimited).bytes(message.last_pending_block_tx);
        /* uint64 updated_at = 7; */
        if (message.updated_at !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.updated_at);
        /* uint64 created_at = 8; */
        if (message.created_at !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.created_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Contract
 */
export const Contract = new Contract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContractQuery$Type extends MessageType<ContractQuery> {
    constructor() {
        super("types.ContractQuery", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_types", kind: "enum", localName: "contract_types", repeat: 1 /*RepeatType.PACKED*/, T: () => ["types.ContractType", ContractType] }
        ]);
    }
    create(value?: PartialMessage<ContractQuery>): ContractQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.contract_types = [];
        if (value !== undefined)
            reflectionMergePartial<ContractQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContractQuery): ContractQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated types.ContractType contract_types */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.contract_types.push(reader.int32());
                    else
                        message.contract_types.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContractQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated types.ContractType contract_types = 2; */
        if (message.contract_types.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.contract_types.length; i++)
                writer.int32(message.contract_types[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.ContractQuery
 */
export const ContractQuery = new ContractQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TokenContract$Type extends MessageType<TokenContract> {
    constructor() {
        super("types.TokenContract", [
            { no: 1, name: "contract_address", kind: "scalar", localName: "contract_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_type", kind: "enum", localName: "contract_type", T: () => ["types.ContractType", ContractType] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "decimals", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "metadata", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "total_supply", kind: "scalar", localName: "total_supply", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "traits", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "token_metadata", kind: "scalar", localName: "token_metadata", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TokenContract>): TokenContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_address = new Uint8Array(0);
        message.contract_type = 0;
        message.name = "";
        message.symbol = "";
        message.decimals = 0;
        message.metadata = new Uint8Array(0);
        message.traits = "";
        message.token_metadata = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<TokenContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TokenContract): TokenContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                case /* types.ContractType contract_type */ 2:
                    message.contract_type = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 4:
                    message.symbol = reader.string();
                    break;
                case /* uint32 decimals */ 5:
                    message.decimals = reader.uint32();
                    break;
                case /* bytes metadata */ 6:
                    message.metadata = reader.bytes();
                    break;
                case /* optional bytes total_supply */ 7:
                    message.total_supply = reader.bytes();
                    break;
                case /* string traits */ 8:
                    message.traits = reader.string();
                    break;
                case /* bytes token_metadata */ 9:
                    message.token_metadata = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TokenContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_address);
        /* types.ContractType contract_type = 2; */
        if (message.contract_type !== 0)
            writer.tag(2, WireType.Varint).int32(message.contract_type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string symbol = 4; */
        if (message.symbol !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.symbol);
        /* uint32 decimals = 5; */
        if (message.decimals !== 0)
            writer.tag(5, WireType.Varint).uint32(message.decimals);
        /* bytes metadata = 6; */
        if (message.metadata.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.metadata);
        /* optional bytes total_supply = 7; */
        if (message.total_supply !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.total_supply);
        /* string traits = 8; */
        if (message.traits !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.traits);
        /* bytes token_metadata = 9; */
        if (message.token_metadata.length)
            writer.tag(9, WireType.LengthDelimited).bytes(message.token_metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TokenContract
 */
export const TokenContract = new TokenContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregationQuery$Type extends MessageType<AggregationQuery> {
    constructor() {
        super("types.AggregationQuery", [
            { no: 1, name: "aggregator_ids", kind: "scalar", localName: "aggregator_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_ids", kind: "scalar", localName: "entity_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<AggregationQuery>): AggregationQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aggregator_ids = [];
        message.entity_ids = [];
        if (value !== undefined)
            reflectionMergePartial<AggregationQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationQuery): AggregationQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string aggregator_ids */ 1:
                    message.aggregator_ids.push(reader.string());
                    break;
                case /* repeated string entity_ids */ 2:
                    message.entity_ids.push(reader.string());
                    break;
                case /* types.Pagination pagination */ 3:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregationQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string aggregator_ids = 1; */
        for (let i = 0; i < message.aggregator_ids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.aggregator_ids[i]);
        /* repeated string entity_ids = 2; */
        for (let i = 0; i < message.entity_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.entity_ids[i]);
        /* types.Pagination pagination = 3; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AggregationQuery
 */
export const AggregationQuery = new AggregationQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregationEntry$Type extends MessageType<AggregationEntry> {
    constructor() {
        super("types.AggregationEntry", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "aggregator_id", kind: "scalar", localName: "aggregator_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_id", kind: "scalar", localName: "entity_id", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "display_value", kind: "scalar", localName: "display_value", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "position", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "model_id", kind: "scalar", localName: "model_id", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "created_at", kind: "scalar", localName: "created_at", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "updated_at", kind: "scalar", localName: "updated_at", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AggregationEntry>): AggregationEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.aggregator_id = "";
        message.entity_id = "";
        message.value = new Uint8Array(0);
        message.display_value = "";
        message.position = 0n;
        message.model_id = "";
        message.created_at = "";
        message.updated_at = "";
        if (value !== undefined)
            reflectionMergePartial<AggregationEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregationEntry): AggregationEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string aggregator_id */ 2:
                    message.aggregator_id = reader.string();
                    break;
                case /* string entity_id */ 3:
                    message.entity_id = reader.string();
                    break;
                case /* bytes value */ 4:
                    message.value = reader.bytes();
                    break;
                case /* string display_value */ 5:
                    message.display_value = reader.string();
                    break;
                case /* uint64 position */ 6:
                    message.position = reader.uint64().toBigInt();
                    break;
                case /* string model_id */ 7:
                    message.model_id = reader.string();
                    break;
                case /* string created_at */ 8:
                    message.created_at = reader.string();
                    break;
                case /* string updated_at */ 9:
                    message.updated_at = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregationEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string aggregator_id = 2; */
        if (message.aggregator_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.aggregator_id);
        /* string entity_id = 3; */
        if (message.entity_id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entity_id);
        /* bytes value = 4; */
        if (message.value.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.value);
        /* string display_value = 5; */
        if (message.display_value !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.display_value);
        /* uint64 position = 6; */
        if (message.position !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.position);
        /* string model_id = 7; */
        if (message.model_id !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.model_id);
        /* string created_at = 8; */
        if (message.created_at !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.created_at);
        /* string updated_at = 9; */
        if (message.updated_at !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AggregationEntry
 */
export const AggregationEntry = new AggregationEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Achievement$Type extends MessageType<Achievement> {
    constructor() {
        super("types.Achievement", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "entity_id", kind: "scalar", localName: "entity_id", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "points", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "start", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "end", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "group", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "tasks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AchievementTask },
            { no: 15, name: "data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "total_completions", kind: "scalar", localName: "total_completions", T: 13 /*ScalarType.UINT32*/ },
            { no: 17, name: "completion_rate", kind: "scalar", localName: "completion_rate", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 18, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Achievement>): Achievement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.world_address = new Uint8Array(0);
        message.namespace = "";
        message.entity_id = "";
        message.hidden = false;
        message.index = 0;
        message.points = 0;
        message.start = "";
        message.end = "";
        message.group = "";
        message.icon = "";
        message.title = "";
        message.description = "";
        message.tasks = [];
        message.total_completions = 0;
        message.completion_rate = 0;
        message.created_at = 0n;
        message.updated_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<Achievement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Achievement): Achievement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes world_address */ 2:
                    message.world_address = reader.bytes();
                    break;
                case /* string namespace */ 3:
                    message.namespace = reader.string();
                    break;
                case /* string entity_id */ 4:
                    message.entity_id = reader.string();
                    break;
                case /* bool hidden */ 5:
                    message.hidden = reader.bool();
                    break;
                case /* uint32 index */ 6:
                    message.index = reader.uint32();
                    break;
                case /* uint32 points */ 7:
                    message.points = reader.uint32();
                    break;
                case /* string start */ 8:
                    message.start = reader.string();
                    break;
                case /* string end */ 9:
                    message.end = reader.string();
                    break;
                case /* string group */ 10:
                    message.group = reader.string();
                    break;
                case /* string icon */ 11:
                    message.icon = reader.string();
                    break;
                case /* string title */ 12:
                    message.title = reader.string();
                    break;
                case /* string description */ 13:
                    message.description = reader.string();
                    break;
                case /* repeated types.AchievementTask tasks */ 14:
                    message.tasks.push(AchievementTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional string data */ 15:
                    message.data = reader.string();
                    break;
                case /* uint32 total_completions */ 16:
                    message.total_completions = reader.uint32();
                    break;
                case /* double completion_rate */ 17:
                    message.completion_rate = reader.double();
                    break;
                case /* uint64 created_at */ 18:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 19:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Achievement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes world_address = 2; */
        if (message.world_address.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.world_address);
        /* string namespace = 3; */
        if (message.namespace !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.namespace);
        /* string entity_id = 4; */
        if (message.entity_id !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.entity_id);
        /* bool hidden = 5; */
        if (message.hidden !== false)
            writer.tag(5, WireType.Varint).bool(message.hidden);
        /* uint32 index = 6; */
        if (message.index !== 0)
            writer.tag(6, WireType.Varint).uint32(message.index);
        /* uint32 points = 7; */
        if (message.points !== 0)
            writer.tag(7, WireType.Varint).uint32(message.points);
        /* string start = 8; */
        if (message.start !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.start);
        /* string end = 9; */
        if (message.end !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.end);
        /* string group = 10; */
        if (message.group !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.group);
        /* string icon = 11; */
        if (message.icon !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.icon);
        /* string title = 12; */
        if (message.title !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.title);
        /* string description = 13; */
        if (message.description !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.description);
        /* repeated types.AchievementTask tasks = 14; */
        for (let i = 0; i < message.tasks.length; i++)
            AchievementTask.internalBinaryWrite(message.tasks[i], writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional string data = 15; */
        if (message.data !== undefined)
            writer.tag(15, WireType.LengthDelimited).string(message.data);
        /* uint32 total_completions = 16; */
        if (message.total_completions !== 0)
            writer.tag(16, WireType.Varint).uint32(message.total_completions);
        /* double completion_rate = 17; */
        if (message.completion_rate !== 0)
            writer.tag(17, WireType.Bit64).double(message.completion_rate);
        /* uint64 created_at = 18; */
        if (message.created_at !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 19; */
        if (message.updated_at !== 0n)
            writer.tag(19, WireType.Varint).uint64(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.Achievement
 */
export const Achievement = new Achievement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AchievementTask$Type extends MessageType<AchievementTask> {
    constructor() {
        super("types.AchievementTask", [
            { no: 1, name: "task_id", kind: "scalar", localName: "task_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "total", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "total_completions", kind: "scalar", localName: "total_completions", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "completion_rate", kind: "scalar", localName: "completion_rate", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AchievementTask>): AchievementTask {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.task_id = "";
        message.description = "";
        message.total = 0;
        message.total_completions = 0;
        message.completion_rate = 0;
        message.created_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<AchievementTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementTask): AchievementTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.task_id = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* uint32 total */ 3:
                    message.total = reader.uint32();
                    break;
                case /* uint32 total_completions */ 4:
                    message.total_completions = reader.uint32();
                    break;
                case /* double completion_rate */ 5:
                    message.completion_rate = reader.double();
                    break;
                case /* uint64 created_at */ 6:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AchievementTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.task_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.task_id);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* uint32 total = 3; */
        if (message.total !== 0)
            writer.tag(3, WireType.Varint).uint32(message.total);
        /* uint32 total_completions = 4; */
        if (message.total_completions !== 0)
            writer.tag(4, WireType.Varint).uint32(message.total_completions);
        /* double completion_rate = 5; */
        if (message.completion_rate !== 0)
            writer.tag(5, WireType.Bit64).double(message.completion_rate);
        /* uint64 created_at = 6; */
        if (message.created_at !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.created_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AchievementTask
 */
export const AchievementTask = new AchievementTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerAchievementStats$Type extends MessageType<PlayerAchievementStats> {
    constructor() {
        super("types.PlayerAchievementStats", [
            { no: 1, name: "total_points", kind: "scalar", localName: "total_points", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "completed_achievements", kind: "scalar", localName: "completed_achievements", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "total_achievements", kind: "scalar", localName: "total_achievements", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "completion_percentage", kind: "scalar", localName: "completion_percentage", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "last_achievement_at", kind: "scalar", localName: "last_achievement_at", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerAchievementStats>): PlayerAchievementStats {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.total_points = 0;
        message.completed_achievements = 0;
        message.total_achievements = 0;
        message.completion_percentage = 0;
        message.created_at = 0n;
        message.updated_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<PlayerAchievementStats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementStats): PlayerAchievementStats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total_points */ 1:
                    message.total_points = reader.uint32();
                    break;
                case /* uint32 completed_achievements */ 2:
                    message.completed_achievements = reader.uint32();
                    break;
                case /* uint32 total_achievements */ 3:
                    message.total_achievements = reader.uint32();
                    break;
                case /* double completion_percentage */ 4:
                    message.completion_percentage = reader.double();
                    break;
                case /* optional uint64 last_achievement_at */ 5:
                    message.last_achievement_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_at */ 6:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 7:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerAchievementStats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total_points = 1; */
        if (message.total_points !== 0)
            writer.tag(1, WireType.Varint).uint32(message.total_points);
        /* uint32 completed_achievements = 2; */
        if (message.completed_achievements !== 0)
            writer.tag(2, WireType.Varint).uint32(message.completed_achievements);
        /* uint32 total_achievements = 3; */
        if (message.total_achievements !== 0)
            writer.tag(3, WireType.Varint).uint32(message.total_achievements);
        /* double completion_percentage = 4; */
        if (message.completion_percentage !== 0)
            writer.tag(4, WireType.Bit64).double(message.completion_percentage);
        /* optional uint64 last_achievement_at = 5; */
        if (message.last_achievement_at !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.last_achievement_at);
        /* uint64 created_at = 6; */
        if (message.created_at !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 7; */
        if (message.updated_at !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementStats
 */
export const PlayerAchievementStats = new PlayerAchievementStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AchievementProgression$Type extends MessageType<AchievementProgression> {
    constructor() {
        super("types.AchievementProgression", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "achievement_id", kind: "scalar", localName: "achievement_id", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "task_id", kind: "scalar", localName: "task_id", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "player_id", kind: "scalar", localName: "player_id", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "completed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "completed_at", kind: "scalar", localName: "completed_at", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "created_at", kind: "scalar", localName: "created_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "updated_at", kind: "scalar", localName: "updated_at", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AchievementProgression>): AchievementProgression {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.achievement_id = "";
        message.task_id = "";
        message.world_address = new Uint8Array(0);
        message.namespace = "";
        message.player_id = new Uint8Array(0);
        message.count = 0;
        message.completed = false;
        message.created_at = 0n;
        message.updated_at = 0n;
        if (value !== undefined)
            reflectionMergePartial<AchievementProgression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementProgression): AchievementProgression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string achievement_id */ 2:
                    message.achievement_id = reader.string();
                    break;
                case /* string task_id */ 3:
                    message.task_id = reader.string();
                    break;
                case /* bytes world_address */ 4:
                    message.world_address = reader.bytes();
                    break;
                case /* string namespace */ 5:
                    message.namespace = reader.string();
                    break;
                case /* bytes player_id */ 6:
                    message.player_id = reader.bytes();
                    break;
                case /* uint32 count */ 7:
                    message.count = reader.uint32();
                    break;
                case /* bool completed */ 8:
                    message.completed = reader.bool();
                    break;
                case /* optional uint64 completed_at */ 9:
                    message.completed_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_at */ 10:
                    message.created_at = reader.uint64().toBigInt();
                    break;
                case /* uint64 updated_at */ 11:
                    message.updated_at = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AchievementProgression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string achievement_id = 2; */
        if (message.achievement_id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.achievement_id);
        /* string task_id = 3; */
        if (message.task_id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.task_id);
        /* bytes world_address = 4; */
        if (message.world_address.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.world_address);
        /* string namespace = 5; */
        if (message.namespace !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.namespace);
        /* bytes player_id = 6; */
        if (message.player_id.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.player_id);
        /* uint32 count = 7; */
        if (message.count !== 0)
            writer.tag(7, WireType.Varint).uint32(message.count);
        /* bool completed = 8; */
        if (message.completed !== false)
            writer.tag(8, WireType.Varint).bool(message.completed);
        /* optional uint64 completed_at = 9; */
        if (message.completed_at !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.completed_at);
        /* uint64 created_at = 10; */
        if (message.created_at !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.created_at);
        /* uint64 updated_at = 11; */
        if (message.updated_at !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.updated_at);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AchievementProgression
 */
export const AchievementProgression = new AchievementProgression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AchievementQuery$Type extends MessageType<AchievementQuery> {
    constructor() {
        super("types.AchievementQuery", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hidden", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<AchievementQuery>): AchievementQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        message.namespaces = [];
        if (value !== undefined)
            reflectionMergePartial<AchievementQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AchievementQuery): AchievementQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* optional bool hidden */ 3:
                    message.hidden = reader.bool();
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AchievementQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 2; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* optional bool hidden = 3; */
        if (message.hidden !== undefined)
            writer.tag(3, WireType.Varint).bool(message.hidden);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.AchievementQuery
 */
export const AchievementQuery = new AchievementQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerAchievementQuery$Type extends MessageType<PlayerAchievementQuery> {
    constructor() {
        super("types.PlayerAchievementQuery", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_addresses", kind: "scalar", localName: "player_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "pagination", kind: "message", T: () => Pagination }
        ]);
    }
    create(value?: PartialMessage<PlayerAchievementQuery>): PlayerAchievementQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        message.namespaces = [];
        message.player_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<PlayerAchievementQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementQuery): PlayerAchievementQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes player_addresses */ 3:
                    message.player_addresses.push(reader.bytes());
                    break;
                case /* types.Pagination pagination */ 4:
                    message.pagination = Pagination.internalBinaryRead(reader, reader.uint32(), options, message.pagination);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerAchievementQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 2; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes player_addresses = 3; */
        for (let i = 0; i < message.player_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.player_addresses[i]);
        /* types.Pagination pagination = 4; */
        if (message.pagination)
            Pagination.internalBinaryWrite(message.pagination, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementQuery
 */
export const PlayerAchievementQuery = new PlayerAchievementQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerAchievementProgress$Type extends MessageType<PlayerAchievementProgress> {
    constructor() {
        super("types.PlayerAchievementProgress", [
            { no: 1, name: "achievement", kind: "message", T: () => Achievement },
            { no: 2, name: "taskProgress", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TaskProgress },
            { no: 3, name: "completed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "progress_percentage", kind: "scalar", localName: "progress_percentage", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerAchievementProgress>): PlayerAchievementProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.taskProgress = [];
        message.completed = false;
        message.progress_percentage = 0;
        if (value !== undefined)
            reflectionMergePartial<PlayerAchievementProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementProgress): PlayerAchievementProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Achievement achievement */ 1:
                    message.achievement = Achievement.internalBinaryRead(reader, reader.uint32(), options, message.achievement);
                    break;
                case /* repeated types.TaskProgress taskProgress */ 2:
                    message.taskProgress.push(TaskProgress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool completed */ 3:
                    message.completed = reader.bool();
                    break;
                case /* double progress_percentage */ 4:
                    message.progress_percentage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerAchievementProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Achievement achievement = 1; */
        if (message.achievement)
            Achievement.internalBinaryWrite(message.achievement, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.TaskProgress taskProgress = 2; */
        for (let i = 0; i < message.taskProgress.length; i++)
            TaskProgress.internalBinaryWrite(message.taskProgress[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool completed = 3; */
        if (message.completed !== false)
            writer.tag(3, WireType.Varint).bool(message.completed);
        /* double progress_percentage = 4; */
        if (message.progress_percentage !== 0)
            writer.tag(4, WireType.Bit64).double(message.progress_percentage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementProgress
 */
export const PlayerAchievementProgress = new PlayerAchievementProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TaskProgress$Type extends MessageType<TaskProgress> {
    constructor() {
        super("types.TaskProgress", [
            { no: 1, name: "task_id", kind: "scalar", localName: "task_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "completed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TaskProgress>): TaskProgress {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.task_id = "";
        message.count = 0;
        message.completed = false;
        if (value !== undefined)
            reflectionMergePartial<TaskProgress>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TaskProgress): TaskProgress {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string task_id */ 1:
                    message.task_id = reader.string();
                    break;
                case /* uint32 count */ 2:
                    message.count = reader.uint32();
                    break;
                case /* bool completed */ 3:
                    message.completed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TaskProgress, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string task_id = 1; */
        if (message.task_id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.task_id);
        /* uint32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).uint32(message.count);
        /* bool completed = 3; */
        if (message.completed !== false)
            writer.tag(3, WireType.Varint).bool(message.completed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.TaskProgress
 */
export const TaskProgress = new TaskProgress$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerAchievementEntry$Type extends MessageType<PlayerAchievementEntry> {
    constructor() {
        super("types.PlayerAchievementEntry", [
            { no: 1, name: "player_address", kind: "scalar", localName: "player_address", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "stats", kind: "message", T: () => PlayerAchievementStats },
            { no: 3, name: "achievements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerAchievementProgress }
        ]);
    }
    create(value?: PartialMessage<PlayerAchievementEntry>): PlayerAchievementEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.player_address = new Uint8Array(0);
        message.achievements = [];
        if (value !== undefined)
            reflectionMergePartial<PlayerAchievementEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerAchievementEntry): PlayerAchievementEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes player_address */ 1:
                    message.player_address = reader.bytes();
                    break;
                case /* types.PlayerAchievementStats stats */ 2:
                    message.stats = PlayerAchievementStats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* repeated types.PlayerAchievementProgress achievements */ 3:
                    message.achievements.push(PlayerAchievementProgress.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerAchievementEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes player_address = 1; */
        if (message.player_address.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.player_address);
        /* types.PlayerAchievementStats stats = 2; */
        if (message.stats)
            PlayerAchievementStats.internalBinaryWrite(message.stats, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated types.PlayerAchievementProgress achievements = 3; */
        for (let i = 0; i < message.achievements.length; i++)
            PlayerAchievementProgress.internalBinaryWrite(message.achievements[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message types.PlayerAchievementEntry
 */
export const PlayerAchievementEntry = new PlayerAchievementEntry$Type();
