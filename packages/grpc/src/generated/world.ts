// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "world.proto" (package "world", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TokenTransferQuery } from "./types";
import { TokenTransfer } from "./types";
import { KeysClause } from "./types";
import { Event } from "./types";
import { EventQuery } from "./types";
import { Query } from "./types";
import { Entity } from "./types";
import { Clause } from "./types";
import { World as World$ } from "./types";
import { TokenContract } from "./types";
import { TokenContractQuery } from "./types";
import { TransactionQuery } from "./types";
import { TokenBalanceQuery } from "./types";
import { Token } from "./types";
import { TokenQuery } from "./types";
import { TokenBalance } from "./types";
import { Contract } from "./types";
import { ContractQuery } from "./types";
import { Controller } from "./types";
import { ControllerQuery } from "./types";
import { Transaction } from "./types";
import { TransactionFilter } from "./types";
/**
 * @generated from protobuf message world.SubscribeTransactionsRequest
 */
export interface SubscribeTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsResponse
 */
export interface SubscribeTransactionsResponse {
    /**
     * @generated from protobuf field: types.Transaction transaction = 1
     */
    transaction?: Transaction;
}
/**
 * @generated from protobuf message world.RetrieveControllersRequest
 */
export interface RetrieveControllersRequest {
    /**
     * @generated from protobuf field: types.ControllerQuery query = 1
     */
    query?: ControllerQuery;
}
/**
 * @generated from protobuf message world.RetrieveControllersResponse
 */
export interface RetrieveControllersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Controller controllers = 2
     */
    controllers: Controller[];
}
/**
 * @generated from protobuf message world.RetrieveContractsRequest
 */
export interface RetrieveContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated from protobuf message world.RetrieveContractsResponse
 */
export interface RetrieveContractsResponse {
    /**
     * @generated from protobuf field: repeated types.Contract contracts = 1
     */
    contracts: Contract[];
}
/**
 * A request to update a token balance subscription
 *
 * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export interface UpdateTokenBalancesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.SubscribeTokenBalancesResponse
 */
export interface SubscribeTokenBalancesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token balance
     *
     * @generated from protobuf field: types.TokenBalance balance = 2
     */
    balance?: TokenBalance;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message world.RetrieveTokensRequest
 */
export interface RetrieveTokensRequest {
    /**
     * @generated from protobuf field: types.TokenQuery query = 1
     */
    query?: TokenQuery;
}
/**
 * A request to subscribe to token updates
 *
 * @generated from protobuf message world.SubscribeTokensRequest
 */
export interface SubscribeTokensRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing tokens
 *
 * @generated from protobuf message world.RetrieveTokensResponse
 */
export interface RetrieveTokensResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Token tokens = 2
     */
    tokens: Token[];
}
/**
 * A response containing token updates
 *
 * @generated from protobuf message world.SubscribeTokensResponse
 */
export interface SubscribeTokensResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token
     *
     * @generated from protobuf field: types.Token token = 2
     */
    token?: Token;
}
/**
 * A request to update a token subscription
 *
 * @generated from protobuf message world.UpdateTokenSubscriptionRequest
 */
export interface UpdateTokenSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesRequest
 */
export interface RetrieveTokenBalancesRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery;
}
/**
 * A request to subscribe to token balance updates
 *
 * @generated from protobuf message world.SubscribeTokenBalancesRequest
 */
export interface SubscribeTokenBalancesRequest {
    /**
     * The account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesResponse
 */
export interface RetrieveTokenBalancesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenBalance balances = 2
     */
    balances: TokenBalance[];
}
/**
 * A request to retrieve transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsRequest
 */
export interface RetrieveTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionQuery query = 1
     */
    query?: TransactionQuery;
}
/**
 * A response containing transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsResponse
 */
export interface RetrieveTransactionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Transaction transactions = 2
     */
    transactions: Transaction[];
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsRequest
 */
export interface RetrieveTokenContractsRequest {
    /**
     * @generated from protobuf field: types.TokenContractQuery query = 1
     */
    query?: TokenContractQuery;
}
/**
 * A response containing token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsResponse
 */
export interface RetrieveTokenContractsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenContract token_contracts = 2
     */
    token_contracts: TokenContract[];
}
/**
 * A request to subscribe to contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsRequest
 */
export interface SubscribeContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * A response containing contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsResponse
 */
export interface SubscribeContractsResponse {
    /**
     * @generated from protobuf field: types.Contract contract = 1
     */
    contract?: Contract;
}
/**
 * A request to retrieve metadata for a specific world ID.
 *
 * @generated from protobuf message world.WorldMetadataRequest
 */
export interface WorldMetadataRequest {
}
/**
 * The metadata response contains addresses and class hashes for the world.
 *
 * @generated from protobuf message world.WorldMetadataResponse
 */
export interface WorldMetadataResponse {
    /**
     * @generated from protobuf field: types.World world = 1
     */
    world?: World$;
}
/**
 * @generated from protobuf message world.SubscribeEntitiesRequest
 */
export interface SubscribeEntitiesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.SubscribeEventMessagesRequest
 */
export interface SubscribeEventMessagesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export interface UpdateEntitiesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
export interface UpdateEventMessagesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.SubscribeEntityResponse
 */
export interface SubscribeEntityResponse {
    /**
     * @generated from protobuf field: types.Entity entity = 1
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: uint64 subscription_id = 2
     */
    subscription_id: bigint;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesRequest
 */
export interface RetrieveEntitiesRequest {
    /**
     * The entities to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query;
}
/**
 * @generated from protobuf message world.RetrieveEventMessagesRequest
 */
export interface RetrieveEventMessagesRequest {
    /**
     * The event messages to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesResponse
 */
export interface RetrieveEntitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Entity entities = 2
     */
    entities: Entity[];
}
/**
 * @generated from protobuf message world.RetrieveEventsRequest
 */
export interface RetrieveEventsRequest {
    /**
     * The events to retrieve
     *
     * @generated from protobuf field: types.EventQuery query = 1
     */
    query?: EventQuery;
}
/**
 * @generated from protobuf message world.RetrieveEventsResponse
 */
export interface RetrieveEventsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Event events = 2
     */
    events: Event[];
}
/**
 * @generated from protobuf message world.SubscribeEventsRequest
 */
export interface SubscribeEventsRequest {
    /**
     * @generated from protobuf field: repeated types.KeysClause keys = 1
     */
    keys: KeysClause[];
}
/**
 * @generated from protobuf message world.SubscribeEventsResponse
 */
export interface SubscribeEventsResponse {
    /**
     * @generated from protobuf field: types.Event event = 1
     */
    event?: Event;
}
/**
 * @generated from protobuf message world.PublishMessageRequest
 */
export interface PublishMessageRequest {
    /**
     * @generated from protobuf field: repeated bytes signature = 1
     */
    signature: Uint8Array[];
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message world.PublishMessageResponse
 */
export interface PublishMessageResponse {
    /**
     * @generated from protobuf field: bytes entity_id = 1
     */
    entity_id: Uint8Array;
}
/**
 * @generated from protobuf message world.PublishMessageBatchRequest
 */
export interface PublishMessageBatchRequest {
    /**
     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1
     */
    messages: PublishMessageRequest[];
}
/**
 * @generated from protobuf message world.PublishMessageBatchResponse
 */
export interface PublishMessageBatchResponse {
    /**
     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1
     */
    responses: PublishMessageResponse[];
}
/**
 * A request to subscribe to token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersRequest
 */
export interface SubscribeTokenTransfersRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 2
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersResponse
 */
export interface SubscribeTokenTransfersResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token transfer
     *
     * @generated from protobuf field: types.TokenTransfer transfer = 2
     */
    transfer?: TokenTransfer;
}
/**
 * A request to update a token transfer subscription
 *
 * @generated from protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
export interface UpdateTokenTransfersSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * A request to retrieve token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersRequest
 */
export interface RetrieveTokenTransfersRequest {
    /**
     * @generated from protobuf field: types.TokenTransferQuery query = 1
     */
    query?: TokenTransferQuery;
}
/**
 * A response containing token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersResponse
 */
export interface RetrieveTokenTransfersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenTransfer transfers = 2
     */
    transfers: TokenTransfer[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {
    constructor() {
        super("world.SubscribeTransactionsRequest", [
            { no: 1, name: "filter", kind: "message", T: () => TransactionFilter }
        ]);
    }
    create(value?: PartialMessage<SubscribeTransactionsRequest>): SubscribeTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsRequest): SubscribeTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsRequest
 */
export const SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {
    constructor() {
        super("world.SubscribeTransactionsResponse", [
            { no: 1, name: "transaction", kind: "message", T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<SubscribeTransactionsResponse>): SubscribeTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsResponse): SubscribeTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsResponse
 */
export const SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {
    constructor() {
        super("world.RetrieveControllersRequest", [
            { no: 1, name: "query", kind: "message", T: () => ControllerQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveControllersRequest>): RetrieveControllersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersRequest): RetrieveControllersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ControllerQuery query */ 1:
                    message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveControllersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ControllerQuery query = 1; */
        if (message.query)
            ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersRequest
 */
export const RetrieveControllersRequest = new RetrieveControllersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {
    constructor() {
        super("world.RetrieveControllersResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "controllers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Controller }
        ]);
    }
    create(value?: PartialMessage<RetrieveControllersResponse>): RetrieveControllersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.controllers = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersResponse): RetrieveControllersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Controller controllers */ 2:
                    message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveControllersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Controller controllers = 2; */
        for (let i = 0; i < message.controllers.length; i++)
            Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersResponse
 */
export const RetrieveControllersResponse = new RetrieveControllersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveContractsRequest$Type extends MessageType<RetrieveContractsRequest> {
    constructor() {
        super("world.RetrieveContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => ContractQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveContractsRequest>): RetrieveContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsRequest): RetrieveContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ContractQuery query */ 1:
                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ContractQuery query = 1; */
        if (message.query)
            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsRequest
 */
export const RetrieveContractsRequest = new RetrieveContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveContractsResponse$Type extends MessageType<RetrieveContractsResponse> {
    constructor() {
        super("world.RetrieveContractsResponse", [
            { no: 1, name: "contracts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<RetrieveContractsResponse>): RetrieveContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contracts = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsResponse): RetrieveContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.Contract contracts */ 1:
                    message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.Contract contracts = 1; */
        for (let i = 0; i < message.contracts.length; i++)
            Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsResponse
 */
export const RetrieveContractsResponse = new RetrieveContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenBalancesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>): UpdateTokenBalancesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenBalancesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenBalancesSubscriptionRequest): UpdateTokenBalancesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 3:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 4:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenBalancesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 3; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 4; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export const UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {
    constructor() {
        super("world.SubscribeTokenBalancesResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "balance", kind: "message", T: () => TokenBalance }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenBalancesResponse>): SubscribeTokenBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesResponse): SubscribeTokenBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.TokenBalance balance */ 2:
                    message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.TokenBalance balance = 2; */
        if (message.balance)
            TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse
 */
export const SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {
    constructor() {
        super("world.RetrieveTokensRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokensRequest>): RetrieveTokensRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensRequest): RetrieveTokensRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenQuery query */ 1:
                    message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenQuery query = 1; */
        if (message.query)
            TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensRequest
 */
export const RetrieveTokensRequest = new RetrieveTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {
    constructor() {
        super("world.SubscribeTokensRequest", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokensRequest>): SubscribeTokensRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensRequest): SubscribeTokensRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 2:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 2; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensRequest
 */
export const SubscribeTokensRequest = new SubscribeTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {
    constructor() {
        super("world.RetrieveTokensResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Token }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokensResponse>): RetrieveTokensResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensResponse): RetrieveTokensResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Token tokens */ 2:
                    message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Token tokens = 2; */
        for (let i = 0; i < message.tokens.length; i++)
            Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensResponse
 */
export const RetrieveTokensResponse = new RetrieveTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {
    constructor() {
        super("world.SubscribeTokensResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token", kind: "message", T: () => Token }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokensResponse>): SubscribeTokensResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensResponse): SubscribeTokensResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Token token */ 2:
                    message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Token token = 2; */
        if (message.token)
            Token.internalBinaryWrite(message.token, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensResponse
 */
export const SubscribeTokensResponse = new SubscribeTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenSubscriptionRequest>): UpdateTokenSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenSubscriptionRequest): UpdateTokenSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest
 */
export const UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {
    constructor() {
        super("world.RetrieveTokenBalancesRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenBalancesRequest>): RetrieveTokenBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesRequest): RetrieveTokenBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenBalanceQuery query */ 1:
                    message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenBalanceQuery query = 1; */
        if (message.query)
            TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest
 */
export const RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {
    constructor() {
        super("world.SubscribeTokenBalancesRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenBalancesRequest>): SubscribeTokenBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesRequest): SubscribeTokenBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest
 */
export const SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {
    constructor() {
        super("world.RetrieveTokenBalancesResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenBalance }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenBalancesResponse>): RetrieveTokenBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesResponse): RetrieveTokenBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenBalance balances */ 2:
                    message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenBalance balances = 2; */
        for (let i = 0; i < message.balances.length; i++)
            TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse
 */
export const RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {
    constructor() {
        super("world.RetrieveTransactionsRequest", [
            { no: 1, name: "query", kind: "message", T: () => TransactionQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTransactionsRequest>): RetrieveTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsRequest): RetrieveTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionQuery query */ 1:
                    message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionQuery query = 1; */
        if (message.query)
            TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsRequest
 */
export const RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {
    constructor() {
        super("world.RetrieveTransactionsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transactions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<RetrieveTransactionsResponse>): RetrieveTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsResponse): RetrieveTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Transaction transactions */ 2:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsResponse
 */
export const RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenContractsRequest$Type extends MessageType<RetrieveTokenContractsRequest> {
    constructor() {
        super("world.RetrieveTokenContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenContractQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenContractsRequest>): RetrieveTokenContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsRequest): RetrieveTokenContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenContractQuery query */ 1:
                    message.query = TokenContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenContractQuery query = 1; */
        if (message.query)
            TokenContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsRequest
 */
export const RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenContractsResponse$Type extends MessageType<RetrieveTokenContractsResponse> {
    constructor() {
        super("world.RetrieveTokenContractsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_contracts", kind: "message", localName: "token_contracts", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenContract }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenContractsResponse>): RetrieveTokenContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.token_contracts = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsResponse): RetrieveTokenContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenContract token_contracts */ 2:
                    message.token_contracts.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenContract token_contracts = 2; */
        for (let i = 0; i < message.token_contracts.length; i++)
            TokenContract.internalBinaryWrite(message.token_contracts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsResponse
 */
export const RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeContractsRequest$Type extends MessageType<SubscribeContractsRequest> {
    constructor() {
        super("world.SubscribeContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => ContractQuery }
        ]);
    }
    create(value?: PartialMessage<SubscribeContractsRequest>): SubscribeContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsRequest): SubscribeContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ContractQuery query */ 1:
                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ContractQuery query = 1; */
        if (message.query)
            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsRequest
 */
export const SubscribeContractsRequest = new SubscribeContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeContractsResponse$Type extends MessageType<SubscribeContractsResponse> {
    constructor() {
        super("world.SubscribeContractsResponse", [
            { no: 1, name: "contract", kind: "message", T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<SubscribeContractsResponse>): SubscribeContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsResponse): SubscribeContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Contract contract */ 1:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Contract contract = 1; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsResponse
 */
export const SubscribeContractsResponse = new SubscribeContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldMetadataRequest$Type extends MessageType<WorldMetadataRequest> {
    constructor() {
        super("world.WorldMetadataRequest", []);
    }
    create(value?: PartialMessage<WorldMetadataRequest>): WorldMetadataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorldMetadataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataRequest): WorldMetadataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldMetadataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataRequest
 */
export const WorldMetadataRequest = new WorldMetadataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldMetadataResponse$Type extends MessageType<WorldMetadataResponse> {
    constructor() {
        super("world.WorldMetadataResponse", [
            { no: 1, name: "world", kind: "message", T: () => World$ }
        ]);
    }
    create(value?: PartialMessage<WorldMetadataResponse>): WorldMetadataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<WorldMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldMetadataResponse): WorldMetadataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.World world */ 1:
                    message.world = World$.internalBinaryRead(reader, reader.uint32(), options, message.world);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldMetadataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.World world = 1; */
        if (message.world)
            World$.internalBinaryWrite(message.world, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataResponse
 */
export const WorldMetadataResponse = new WorldMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {
    constructor() {
        super("world.SubscribeEntitiesRequest", [
            { no: 1, name: "clause", kind: "message", T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<SubscribeEntitiesRequest>): SubscribeEntitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntitiesRequest): SubscribeEntitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntitiesRequest
 */
export const SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventMessagesRequest$Type extends MessageType<SubscribeEventMessagesRequest> {
    constructor() {
        super("world.SubscribeEventMessagesRequest", [
            { no: 1, name: "clause", kind: "message", T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventMessagesRequest>): SubscribeEventMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventMessagesRequest): SubscribeEventMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventMessagesRequest
 */
export const SubscribeEventMessagesRequest = new SubscribeEventMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {
    constructor() {
        super("world.UpdateEntitiesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clause", kind: "message", T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<UpdateEntitiesSubscriptionRequest>): UpdateEntitiesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateEntitiesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEntitiesSubscriptionRequest): UpdateEntitiesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Clause clause */ 2:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateEntitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Clause clause = 2; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export const UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEventMessagesSubscriptionRequest$Type extends MessageType<UpdateEventMessagesSubscriptionRequest> {
    constructor() {
        super("world.UpdateEventMessagesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clause", kind: "message", T: () => Clause }
        ]);
    }
    create(value?: PartialMessage<UpdateEventMessagesSubscriptionRequest>): UpdateEventMessagesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateEventMessagesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEventMessagesSubscriptionRequest): UpdateEventMessagesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Clause clause */ 2:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateEventMessagesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Clause clause = 2; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
export const UpdateEventMessagesSubscriptionRequest = new UpdateEventMessagesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {
    constructor() {
        super("world.SubscribeEntityResponse", [
            { no: 1, name: "entity", kind: "message", T: () => Entity },
            { no: 2, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeEntityResponse>): SubscribeEntityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntityResponse): SubscribeEntityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* uint64 subscription_id */ 2:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 subscription_id = 2; */
        if (message.subscription_id !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.subscription_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntityResponse
 */
export const SubscribeEntityResponse = new SubscribeEntityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {
    constructor() {
        super("world.RetrieveEntitiesRequest", [
            { no: 1, name: "query", kind: "message", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<RetrieveEntitiesRequest>): RetrieveEntitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesRequest): RetrieveEntitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Query query */ 1:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesRequest
 */
export const RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventMessagesRequest$Type extends MessageType<RetrieveEventMessagesRequest> {
    constructor() {
        super("world.RetrieveEventMessagesRequest", [
            { no: 1, name: "query", kind: "message", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<RetrieveEventMessagesRequest>): RetrieveEventMessagesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventMessagesRequest): RetrieveEventMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Query query */ 1:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEventMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventMessagesRequest
 */
export const RetrieveEventMessagesRequest = new RetrieveEventMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {
    constructor() {
        super("world.RetrieveEntitiesResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<RetrieveEntitiesResponse>): RetrieveEntitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesResponse): RetrieveEntitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Entity entities */ 2:
                    message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Entity entities = 2; */
        for (let i = 0; i < message.entities.length; i++)
            Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesResponse
 */
export const RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {
    constructor() {
        super("world.RetrieveEventsRequest", [
            { no: 1, name: "query", kind: "message", T: () => EventQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveEventsRequest>): RetrieveEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsRequest): RetrieveEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.EventQuery query */ 1:
                    message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.EventQuery query = 1; */
        if (message.query)
            EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsRequest
 */
export const RetrieveEventsRequest = new RetrieveEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {
    constructor() {
        super("world.RetrieveEventsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<RetrieveEventsResponse>): RetrieveEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsResponse): RetrieveEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Event events */ 2:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsResponse
 */
export const RetrieveEventsResponse = new RetrieveEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor() {
        super("world.SubscribeEventsRequest", [
            { no: 1, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KeysClause }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.KeysClause keys */ 1:
                    message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.KeysClause keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsRequest
 */
export const SubscribeEventsRequest = new SubscribeEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor() {
        super("world.SubscribeEventsResponse", [
            { no: 1, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Event event */ 1:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Event event = 1; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsResponse
 */
export const SubscribeEventsResponse = new SubscribeEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {
    constructor() {
        super("world.PublishMessageRequest", [
            { no: 1, name: "signature", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublishMessageRequest>): PublishMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = [];
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<PublishMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageRequest): PublishMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes signature */ 1:
                    message.signature.push(reader.bytes());
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes signature = 1; */
        for (let i = 0; i < message.signature.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature[i]);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageRequest
 */
export const PublishMessageRequest = new PublishMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {
    constructor() {
        super("world.PublishMessageResponse", [
            { no: 1, name: "entity_id", kind: "scalar", localName: "entity_id", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PublishMessageResponse>): PublishMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entity_id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PublishMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageResponse): PublishMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes entity_id */ 1:
                    message.entity_id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes entity_id = 1; */
        if (message.entity_id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.entity_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageResponse
 */
export const PublishMessageResponse = new PublishMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {
    constructor() {
        super("world.PublishMessageBatchRequest", [
            { no: 1, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageRequest }
        ]);
    }
    create(value?: PartialMessage<PublishMessageBatchRequest>): PublishMessageBatchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchRequest): PublishMessageBatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageRequest messages */ 1:
                    message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.PublishMessageRequest messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchRequest
 */
export const PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {
    constructor() {
        super("world.PublishMessageBatchResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageResponse }
        ]);
    }
    create(value?: PartialMessage<PublishMessageBatchResponse>): PublishMessageBatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responses = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchResponse): PublishMessageBatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageResponse responses */ 1:
                    message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.PublishMessageResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchResponse
 */
export const PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenTransfersRequest$Type extends MessageType<SubscribeTokenTransfersRequest> {
    constructor() {
        super("world.SubscribeTokenTransfersRequest", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenTransfersRequest>): SubscribeTokenTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersRequest): SubscribeTokenTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 2:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 2; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersRequest
 */
export const SubscribeTokenTransfersRequest = new SubscribeTokenTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenTransfersResponse$Type extends MessageType<SubscribeTokenTransfersResponse> {
    constructor() {
        super("world.SubscribeTokenTransfersResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "transfer", kind: "message", T: () => TokenTransfer }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenTransfersResponse>): SubscribeTokenTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersResponse): SubscribeTokenTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.TokenTransfer transfer */ 2:
                    message.transfer = TokenTransfer.internalBinaryRead(reader, reader.uint32(), options, message.transfer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.TokenTransfer transfer = 2; */
        if (message.transfer)
            TokenTransfer.internalBinaryWrite(message.transfer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersResponse
 */
export const SubscribeTokenTransfersResponse = new SubscribeTokenTransfersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenTransfersSubscriptionRequest$Type extends MessageType<UpdateTokenTransfersSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenTransfersSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenTransfersSubscriptionRequest>): UpdateTokenTransfersSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenTransfersSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenTransfersSubscriptionRequest): UpdateTokenTransfersSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 3:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 4:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenTransfersSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 3; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 4; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
export const UpdateTokenTransfersSubscriptionRequest = new UpdateTokenTransfersSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenTransfersRequest$Type extends MessageType<RetrieveTokenTransfersRequest> {
    constructor() {
        super("world.RetrieveTokenTransfersRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenTransferQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenTransfersRequest>): RetrieveTokenTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersRequest): RetrieveTokenTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenTransferQuery query */ 1:
                    message.query = TokenTransferQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenTransferQuery query = 1; */
        if (message.query)
            TokenTransferQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersRequest
 */
export const RetrieveTokenTransfersRequest = new RetrieveTokenTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenTransfersResponse$Type extends MessageType<RetrieveTokenTransfersResponse> {
    constructor() {
        super("world.RetrieveTokenTransfersResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transfers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenTransfer }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenTransfersResponse>): RetrieveTokenTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.transfers = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersResponse): RetrieveTokenTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenTransfer transfers */ 2:
                    message.transfers.push(TokenTransfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenTransfer transfers = 2; */
        for (let i = 0; i < message.transfers.length; i++)
            TokenTransfer.internalBinaryWrite(message.transfers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersResponse
 */
export const RetrieveTokenTransfersResponse = new RetrieveTokenTransfersResponse$Type();
/**
 * @generated ServiceType for protobuf service world.World
 */
export const World = new ServiceType("world.World", [
    { name: "SubscribeContracts", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },
    { name: "WorldMetadata", options: {}, I: WorldMetadataRequest, O: WorldMetadataResponse },
    { name: "SubscribeEntities", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
    { name: "UpdateEntitiesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
    { name: "RetrieveEntities", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
    { name: "SubscribeEventMessages", serverStreaming: true, options: {}, I: SubscribeEventMessagesRequest, O: SubscribeEntityResponse },
    { name: "UpdateEventMessagesSubscription", options: {}, I: UpdateEventMessagesSubscriptionRequest, O: Empty },
    { name: "SubscribeTokenBalances", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },
    { name: "UpdateTokenBalancesSubscription", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },
    { name: "SubscribeTokens", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },
    { name: "UpdateTokensSubscription", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },
    { name: "SubscribeTokenTransfers", serverStreaming: true, options: {}, I: SubscribeTokenTransfersRequest, O: SubscribeTokenTransfersResponse },
    { name: "UpdateTokenTransfersSubscription", options: {}, I: UpdateTokenTransfersSubscriptionRequest, O: Empty },
    { name: "RetrieveEventMessages", options: {}, I: RetrieveEventMessagesRequest, O: RetrieveEntitiesResponse },
    { name: "RetrieveEvents", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },
    { name: "SubscribeEvents", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },
    { name: "RetrieveTokens", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },
    { name: "RetrieveTokenTransfers", options: {}, I: RetrieveTokenTransfersRequest, O: RetrieveTokenTransfersResponse },
    { name: "RetrieveTokenBalances", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },
    { name: "RetrieveTransactions", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },
    { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },
    { name: "RetrieveControllers", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },
    { name: "RetrieveContracts", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },
    { name: "RetrieveTokenContracts", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },
    { name: "PublishMessage", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },
    { name: "PublishMessageBatch", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse }
]);
