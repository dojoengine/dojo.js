// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "world.proto" (package "world", syntax proto3)
// tslint:disable
import { SqlQueryResponse } from "./types";
import { SqlQueryRequest } from "./types";
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PlayerAchievementEntry } from "./types";
import { PlayerAchievementQuery } from "./types";
import { Achievement } from "./types";
import { AchievementQuery } from "./types";
import { AchievementProgression } from "./types";
import { Activity } from "./types";
import { ActivityQuery } from "./types";
import { AggregationEntry } from "./types";
import { AggregationQuery } from "./types";
import { TokenTransferQuery } from "./types";
import { TokenTransfer } from "./types";
import { KeysClause } from "./types";
import { Event } from "./types";
import { EventQuery } from "./types";
import { Query } from "./types";
import { Entity } from "./types";
import { Clause } from "./types";
import { World as World$ } from "./types";
import { TokenContract } from "./types";
import { TokenContractQuery } from "./types";
import { TransactionQuery } from "./types";
import { TokenBalanceQuery } from "./types";
import { Token } from "./types";
import { TokenQuery } from "./types";
import { TokenBalance } from "./types";
import { Contract } from "./types";
import { ContractQuery } from "./types";
import { Controller } from "./types";
import { ControllerQuery } from "./types";
import { Transaction } from "./types";
import { TransactionFilter } from "./types";
/**
 * @generated from protobuf message world.SubscribeTransactionsRequest
 */
export interface SubscribeTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsResponse
 */
export interface SubscribeTransactionsResponse {
    /**
     * @generated from protobuf field: types.Transaction transaction = 1
     */
    transaction?: Transaction;
}
/**
 * @generated from protobuf message world.RetrieveControllersRequest
 */
export interface RetrieveControllersRequest {
    /**
     * @generated from protobuf field: types.ControllerQuery query = 1
     */
    query?: ControllerQuery;
}
/**
 * @generated from protobuf message world.RetrieveControllersResponse
 */
export interface RetrieveControllersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Controller controllers = 2
     */
    controllers: Controller[];
}
/**
 * @generated from protobuf message world.RetrieveContractsRequest
 */
export interface RetrieveContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * @generated from protobuf message world.RetrieveContractsResponse
 */
export interface RetrieveContractsResponse {
    /**
     * @generated from protobuf field: repeated types.Contract contracts = 1
     */
    contracts: Contract[];
}
/**
 * A request to update a token balance subscription
 *
 * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export interface UpdateTokenBalancesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.SubscribeTokenBalancesResponse
 */
export interface SubscribeTokenBalancesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token balance
     *
     * @generated from protobuf field: types.TokenBalance balance = 2
     */
    balance?: TokenBalance;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message world.RetrieveTokensRequest
 */
export interface RetrieveTokensRequest {
    /**
     * @generated from protobuf field: types.TokenQuery query = 1
     */
    query?: TokenQuery;
}
/**
 * A request to subscribe to token updates
 *
 * @generated from protobuf message world.SubscribeTokensRequest
 */
export interface SubscribeTokensRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing tokens
 *
 * @generated from protobuf message world.RetrieveTokensResponse
 */
export interface RetrieveTokensResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Token tokens = 2
     */
    tokens: Token[];
}
/**
 * A response containing token updates
 *
 * @generated from protobuf message world.SubscribeTokensResponse
 */
export interface SubscribeTokensResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token
     *
     * @generated from protobuf field: types.Token token = 2
     */
    token?: Token;
}
/**
 * A request to update a token subscription
 *
 * @generated from protobuf message world.UpdateTokenSubscriptionRequest
 */
export interface UpdateTokenSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesRequest
 */
export interface RetrieveTokenBalancesRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery;
}
/**
 * A request to subscribe to token balance updates
 *
 * @generated from protobuf message world.SubscribeTokenBalancesRequest
 */
export interface SubscribeTokenBalancesRequest {
    /**
     * The account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesResponse
 */
export interface RetrieveTokenBalancesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenBalance balances = 2
     */
    balances: TokenBalance[];
}
/**
 * A request to retrieve transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsRequest
 */
export interface RetrieveTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionQuery query = 1
     */
    query?: TransactionQuery;
}
/**
 * A response containing transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsResponse
 */
export interface RetrieveTransactionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Transaction transactions = 2
     */
    transactions: Transaction[];
}
/**
 * A request to retrieve token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsRequest
 */
export interface RetrieveTokenContractsRequest {
    /**
     * @generated from protobuf field: types.TokenContractQuery query = 1
     */
    query?: TokenContractQuery;
}
/**
 * A response containing token contracts
 *
 * @generated from protobuf message world.RetrieveTokenContractsResponse
 */
export interface RetrieveTokenContractsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenContract token_contracts = 2
     */
    token_contracts: TokenContract[];
}
/**
 * A request to subscribe to contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsRequest
 */
export interface SubscribeContractsRequest {
    /**
     * @generated from protobuf field: types.ContractQuery query = 1
     */
    query?: ContractQuery;
}
/**
 * A response containing contract updates.
 *
 * @generated from protobuf message world.SubscribeContractsResponse
 */
export interface SubscribeContractsResponse {
    /**
     * @generated from protobuf field: types.Contract contract = 1
     */
    contract?: Contract;
}
/**
 * A request to retrieve metadata for a specific world ID.
 *
 * @generated from protobuf message world.WorldsRequest
 */
export interface WorldsRequest {
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
}
/**
 * The metadata response contains addresses and class hashes for the world.
 *
 * @generated from protobuf message world.WorldsResponse
 */
export interface WorldsResponse {
    /**
     * @generated from protobuf field: repeated types.World worlds = 1
     */
    worlds: World$[];
}
/**
 * @generated from protobuf message world.SubscribeEntitiesRequest
 */
export interface SubscribeEntitiesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export interface UpdateEntitiesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause;
    /**
     * @generated from protobuf field: repeated bytes world_addresses = 3
     */
    world_addresses: Uint8Array[];
}
/**
 * @generated from protobuf message world.SubscribeEntityResponse
 */
export interface SubscribeEntityResponse {
    /**
     * @generated from protobuf field: types.Entity entity = 1
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: uint64 subscription_id = 2
     */
    subscription_id: bigint;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesRequest
 */
export interface RetrieveEntitiesRequest {
    /**
     * The entities to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesResponse
 */
export interface RetrieveEntitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Entity entities = 2
     */
    entities: Entity[];
}
/**
 * @generated from protobuf message world.RetrieveEventsRequest
 */
export interface RetrieveEventsRequest {
    /**
     * The events to retrieve
     *
     * @generated from protobuf field: types.EventQuery query = 1
     */
    query?: EventQuery;
}
/**
 * @generated from protobuf message world.RetrieveEventsResponse
 */
export interface RetrieveEventsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Event events = 2
     */
    events: Event[];
}
/**
 * @generated from protobuf message world.SubscribeEventsRequest
 */
export interface SubscribeEventsRequest {
    /**
     * @generated from protobuf field: repeated types.KeysClause keys = 1
     */
    keys: KeysClause[];
}
/**
 * @generated from protobuf message world.SubscribeEventsResponse
 */
export interface SubscribeEventsResponse {
    /**
     * @generated from protobuf field: types.Event event = 1
     */
    event?: Event;
}
/**
 * @generated from protobuf message world.PublishMessageRequest
 */
export interface PublishMessageRequest {
    /**
     * @generated from protobuf field: repeated bytes signature = 1
     */
    signature: Uint8Array[];
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: bytes world_address = 3
     */
    world_address: Uint8Array;
}
/**
 * @generated from protobuf message world.PublishMessageResponse
 */
export interface PublishMessageResponse {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * @generated from protobuf message world.PublishMessageBatchRequest
 */
export interface PublishMessageBatchRequest {
    /**
     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1
     */
    messages: PublishMessageRequest[];
}
/**
 * @generated from protobuf message world.PublishMessageBatchResponse
 */
export interface PublishMessageBatchResponse {
    /**
     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1
     */
    responses: PublishMessageResponse[];
}
/**
 * A request to subscribe to token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersRequest
 */
export interface SubscribeTokenTransfersRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 2
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token transfer updates
 *
 * @generated from protobuf message world.SubscribeTokenTransfersResponse
 */
export interface SubscribeTokenTransfersResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token transfer
     *
     * @generated from protobuf field: types.TokenTransfer transfer = 2
     */
    transfer?: TokenTransfer;
}
/**
 * A request to update a token transfer subscription
 *
 * @generated from protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
export interface UpdateTokenTransfersSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to (as sender or recipient)
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * A request to retrieve token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersRequest
 */
export interface RetrieveTokenTransfersRequest {
    /**
     * @generated from protobuf field: types.TokenTransferQuery query = 1
     */
    query?: TokenTransferQuery;
}
/**
 * A response containing token transfers
 *
 * @generated from protobuf message world.RetrieveTokenTransfersResponse
 */
export interface RetrieveTokenTransfersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenTransfer transfers = 2
     */
    transfers: TokenTransfer[];
}
/**
 * A request to retrieve aggregations (leaderboards, stats, rankings)
 *
 * @generated from protobuf message world.RetrieveAggregationsRequest
 */
export interface RetrieveAggregationsRequest {
    /**
     * @generated from protobuf field: types.AggregationQuery query = 1
     */
    query?: AggregationQuery;
}
/**
 * A response containing aggregation entries
 *
 * @generated from protobuf message world.RetrieveAggregationsResponse
 */
export interface RetrieveAggregationsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.AggregationEntry entries = 2
     */
    entries: AggregationEntry[];
}
/**
 * A request to subscribe to aggregations updates
 *
 * @generated from protobuf message world.SubscribeAggregationsRequest
 */
export interface SubscribeAggregationsRequest {
    /**
     * Filter by aggregator IDs (e.g., "top_scores", "most_wins")
     *
     * @generated from protobuf field: repeated string aggregator_ids = 1
     */
    aggregator_ids: string[];
    /**
     * Filter by entity IDs (e.g., specific player addresses)
     *
     * @generated from protobuf field: repeated string entity_ids = 2
     */
    entity_ids: string[];
}
/**
 * A response containing aggregation update
 *
 * @generated from protobuf message world.SubscribeAggregationsResponse
 */
export interface SubscribeAggregationsResponse {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.AggregationEntry entry = 2
     */
    entry?: AggregationEntry;
}
/**
 * A request to update an aggregations subscription
 *
 * @generated from protobuf message world.UpdateAggregationsSubscriptionRequest
 */
export interface UpdateAggregationsSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by aggregator IDs
     *
     * @generated from protobuf field: repeated string aggregator_ids = 2
     */
    aggregator_ids: string[];
    /**
     * Filter by entity IDs
     *
     * @generated from protobuf field: repeated string entity_ids = 3
     */
    entity_ids: string[];
}
/**
 * A response for updating an aggregations subscription
 *
 * @generated from protobuf message world.UpdateAggregationsSubscriptionResponse
 */
export interface UpdateAggregationsSubscriptionResponse {
}
/**
 * A request to retrieve activities
 *
 * @generated from protobuf message world.RetrieveActivitiesRequest
 */
export interface RetrieveActivitiesRequest {
    /**
     * @generated from protobuf field: types.ActivityQuery query = 1
     */
    query?: ActivityQuery;
}
/**
 * A response containing activities
 *
 * @generated from protobuf message world.RetrieveActivitiesResponse
 */
export interface RetrieveActivitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Activity activities = 2
     */
    activities: Activity[];
}
/**
 * A request to subscribe to activity updates
 *
 * @generated from protobuf message world.SubscribeActivitiesRequest
 */
export interface SubscribeActivitiesRequest {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 3
     */
    caller_addresses: Uint8Array[];
}
/**
 * A response containing activity updates
 *
 * @generated from protobuf message world.SubscribeActivitiesResponse
 */
export interface SubscribeActivitiesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The activity update
     *
     * @generated from protobuf field: types.Activity activity = 2
     */
    activity?: Activity;
}
/**
 * A request to update an activities subscription
 *
 * @generated from protobuf message world.UpdateActivitiesSubscriptionRequest
 */
export interface UpdateActivitiesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 3
     */
    namespaces: string[];
    /**
     * Filter by caller addresses
     *
     * @generated from protobuf field: repeated bytes caller_addresses = 4
     */
    caller_addresses: Uint8Array[];
}
/**
 * A request to subscribe to achievement progression updates
 *
 * @generated from protobuf message world.SubscribeAchievementProgressionsRequest
 */
export interface SubscribeAchievementProgressionsRequest {
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 1
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 2
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 3
     */
    player_addresses: Uint8Array[];
    /**
     * Filter by achievement IDs
     *
     * @generated from protobuf field: repeated string achievement_ids = 4
     */
    achievement_ids: string[];
}
/**
 * A response containing achievement progression updates
 *
 * @generated from protobuf message world.SubscribeAchievementProgressionsResponse
 */
export interface SubscribeAchievementProgressionsResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The achievement progression update
     *
     * @generated from protobuf field: types.AchievementProgression progression = 2
     */
    progression?: AchievementProgression;
}
/**
 * A request to update an achievement progressions subscription
 *
 * @generated from protobuf message world.UpdateAchievementProgressionsSubscriptionRequest
 */
export interface UpdateAchievementProgressionsSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * Filter by world addresses
     *
     * @generated from protobuf field: repeated bytes world_addresses = 2
     */
    world_addresses: Uint8Array[];
    /**
     * Filter by namespaces
     *
     * @generated from protobuf field: repeated string namespaces = 3
     */
    namespaces: string[];
    /**
     * Filter by player addresses
     *
     * @generated from protobuf field: repeated bytes player_addresses = 4
     */
    player_addresses: Uint8Array[];
    /**
     * Filter by achievement IDs
     *
     * @generated from protobuf field: repeated string achievement_ids = 5
     */
    achievement_ids: string[];
}
/**
 * A request to retrieve achievements
 *
 * @generated from protobuf message world.RetrieveAchievementsRequest
 */
export interface RetrieveAchievementsRequest {
    /**
     * @generated from protobuf field: types.AchievementQuery query = 1
     */
    query?: AchievementQuery;
}
/**
 * A response containing achievements
 *
 * @generated from protobuf message world.RetrieveAchievementsResponse
 */
export interface RetrieveAchievementsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Achievement achievements = 2
     */
    achievements: Achievement[];
}
/**
 * A request to retrieve player achievements
 *
 * @generated from protobuf message world.RetrievePlayerAchievementsRequest
 */
export interface RetrievePlayerAchievementsRequest {
    /**
     * @generated from protobuf field: types.PlayerAchievementQuery query = 1
     */
    query?: PlayerAchievementQuery;
}
/**
 * A response containing player achievement data (paginated)
 *
 * @generated from protobuf message world.RetrievePlayerAchievementsResponse
 */
export interface RetrievePlayerAchievementsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.PlayerAchievementEntry players = 2
     */
    players: PlayerAchievementEntry[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {
    constructor() {
        super("world.SubscribeTransactionsRequest", [
            { no: 1, name: "filter", kind: "message", T: () => TransactionFilter }
        ]);
    }
    create(value?: PartialMessage<SubscribeTransactionsRequest>): SubscribeTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsRequest): SubscribeTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsRequest
 */
export const SubscribeTransactionsRequest = new SubscribeTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {
    constructor() {
        super("world.SubscribeTransactionsResponse", [
            { no: 1, name: "transaction", kind: "message", T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<SubscribeTransactionsResponse>): SubscribeTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTransactionsResponse): SubscribeTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsResponse
 */
export const SubscribeTransactionsResponse = new SubscribeTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {
    constructor() {
        super("world.RetrieveControllersRequest", [
            { no: 1, name: "query", kind: "message", T: () => ControllerQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveControllersRequest>): RetrieveControllersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersRequest): RetrieveControllersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ControllerQuery query */ 1:
                    message.query = ControllerQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveControllersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ControllerQuery query = 1; */
        if (message.query)
            ControllerQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersRequest
 */
export const RetrieveControllersRequest = new RetrieveControllersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {
    constructor() {
        super("world.RetrieveControllersResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "controllers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Controller }
        ]);
    }
    create(value?: PartialMessage<RetrieveControllersResponse>): RetrieveControllersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.controllers = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveControllersResponse): RetrieveControllersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Controller controllers */ 2:
                    message.controllers.push(Controller.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveControllersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Controller controllers = 2; */
        for (let i = 0; i < message.controllers.length; i++)
            Controller.internalBinaryWrite(message.controllers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersResponse
 */
export const RetrieveControllersResponse = new RetrieveControllersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveContractsRequest$Type extends MessageType<RetrieveContractsRequest> {
    constructor() {
        super("world.RetrieveContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => ContractQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveContractsRequest>): RetrieveContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsRequest): RetrieveContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ContractQuery query */ 1:
                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ContractQuery query = 1; */
        if (message.query)
            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsRequest
 */
export const RetrieveContractsRequest = new RetrieveContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveContractsResponse$Type extends MessageType<RetrieveContractsResponse> {
    constructor() {
        super("world.RetrieveContractsResponse", [
            { no: 1, name: "contracts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<RetrieveContractsResponse>): RetrieveContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contracts = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveContractsResponse): RetrieveContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.Contract contracts */ 1:
                    message.contracts.push(Contract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.Contract contracts = 1; */
        for (let i = 0; i < message.contracts.length; i++)
            Contract.internalBinaryWrite(message.contracts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveContractsResponse
 */
export const RetrieveContractsResponse = new RetrieveContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenBalancesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>): UpdateTokenBalancesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenBalancesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenBalancesSubscriptionRequest): UpdateTokenBalancesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 3:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 4:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenBalancesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 3; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 4; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export const UpdateTokenBalancesSubscriptionRequest = new UpdateTokenBalancesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {
    constructor() {
        super("world.SubscribeTokenBalancesResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "balance", kind: "message", T: () => TokenBalance }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenBalancesResponse>): SubscribeTokenBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesResponse): SubscribeTokenBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.TokenBalance balance */ 2:
                    message.balance = TokenBalance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.TokenBalance balance = 2; */
        if (message.balance)
            TokenBalance.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse
 */
export const SubscribeTokenBalancesResponse = new SubscribeTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {
    constructor() {
        super("world.RetrieveTokensRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokensRequest>): RetrieveTokensRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensRequest): RetrieveTokensRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenQuery query */ 1:
                    message.query = TokenQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenQuery query = 1; */
        if (message.query)
            TokenQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensRequest
 */
export const RetrieveTokensRequest = new RetrieveTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {
    constructor() {
        super("world.SubscribeTokensRequest", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokensRequest>): SubscribeTokensRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensRequest): SubscribeTokensRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 2:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 2; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensRequest
 */
export const SubscribeTokensRequest = new SubscribeTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {
    constructor() {
        super("world.RetrieveTokensResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tokens", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Token }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokensResponse>): RetrieveTokensResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokensResponse): RetrieveTokensResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Token tokens */ 2:
                    message.tokens.push(Token.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Token tokens = 2; */
        for (let i = 0; i < message.tokens.length; i++)
            Token.internalBinaryWrite(message.tokens[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensResponse
 */
export const RetrieveTokensResponse = new RetrieveTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {
    constructor() {
        super("world.SubscribeTokensResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "token", kind: "message", T: () => Token }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokensResponse>): SubscribeTokensResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokensResponse): SubscribeTokensResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Token token */ 2:
                    message.token = Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Token token = 2; */
        if (message.token)
            Token.internalBinaryWrite(message.token, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensResponse
 */
export const SubscribeTokensResponse = new SubscribeTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenSubscriptionRequest>): UpdateTokenSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenSubscriptionRequest): UpdateTokenSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest
 */
export const UpdateTokenSubscriptionRequest = new UpdateTokenSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {
    constructor() {
        super("world.RetrieveTokenBalancesRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenBalanceQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenBalancesRequest>): RetrieveTokenBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesRequest): RetrieveTokenBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenBalanceQuery query */ 1:
                    message.query = TokenBalanceQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenBalanceQuery query = 1; */
        if (message.query)
            TokenBalanceQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest
 */
export const RetrieveTokenBalancesRequest = new RetrieveTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {
    constructor() {
        super("world.SubscribeTokenBalancesRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenBalancesRequest>): SubscribeTokenBalancesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenBalancesRequest): SubscribeTokenBalancesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenBalancesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest
 */
export const SubscribeTokenBalancesRequest = new SubscribeTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {
    constructor() {
        super("world.RetrieveTokenBalancesResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balances", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenBalance }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenBalancesResponse>): RetrieveTokenBalancesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenBalancesResponse): RetrieveTokenBalancesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenBalance balances */ 2:
                    message.balances.push(TokenBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenBalancesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenBalance balances = 2; */
        for (let i = 0; i < message.balances.length; i++)
            TokenBalance.internalBinaryWrite(message.balances[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse
 */
export const RetrieveTokenBalancesResponse = new RetrieveTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {
    constructor() {
        super("world.RetrieveTransactionsRequest", [
            { no: 1, name: "query", kind: "message", T: () => TransactionQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTransactionsRequest>): RetrieveTransactionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsRequest): RetrieveTransactionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionQuery query */ 1:
                    message.query = TransactionQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTransactionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TransactionQuery query = 1; */
        if (message.query)
            TransactionQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsRequest
 */
export const RetrieveTransactionsRequest = new RetrieveTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {
    constructor() {
        super("world.RetrieveTransactionsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transactions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<RetrieveTransactionsResponse>): RetrieveTransactionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTransactionsResponse): RetrieveTransactionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Transaction transactions */ 2:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTransactionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsResponse
 */
export const RetrieveTransactionsResponse = new RetrieveTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenContractsRequest$Type extends MessageType<RetrieveTokenContractsRequest> {
    constructor() {
        super("world.RetrieveTokenContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenContractQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenContractsRequest>): RetrieveTokenContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsRequest): RetrieveTokenContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenContractQuery query */ 1:
                    message.query = TokenContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenContractQuery query = 1; */
        if (message.query)
            TokenContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsRequest
 */
export const RetrieveTokenContractsRequest = new RetrieveTokenContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenContractsResponse$Type extends MessageType<RetrieveTokenContractsResponse> {
    constructor() {
        super("world.RetrieveTokenContractsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token_contracts", kind: "message", localName: "token_contracts", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenContract }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenContractsResponse>): RetrieveTokenContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.token_contracts = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenContractsResponse): RetrieveTokenContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenContract token_contracts */ 2:
                    message.token_contracts.push(TokenContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenContract token_contracts = 2; */
        for (let i = 0; i < message.token_contracts.length; i++)
            TokenContract.internalBinaryWrite(message.token_contracts[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenContractsResponse
 */
export const RetrieveTokenContractsResponse = new RetrieveTokenContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeContractsRequest$Type extends MessageType<SubscribeContractsRequest> {
    constructor() {
        super("world.SubscribeContractsRequest", [
            { no: 1, name: "query", kind: "message", T: () => ContractQuery }
        ]);
    }
    create(value?: PartialMessage<SubscribeContractsRequest>): SubscribeContractsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeContractsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsRequest): SubscribeContractsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ContractQuery query */ 1:
                    message.query = ContractQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeContractsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ContractQuery query = 1; */
        if (message.query)
            ContractQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsRequest
 */
export const SubscribeContractsRequest = new SubscribeContractsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeContractsResponse$Type extends MessageType<SubscribeContractsResponse> {
    constructor() {
        super("world.SubscribeContractsResponse", [
            { no: 1, name: "contract", kind: "message", T: () => Contract }
        ]);
    }
    create(value?: PartialMessage<SubscribeContractsResponse>): SubscribeContractsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeContractsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeContractsResponse): SubscribeContractsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Contract contract */ 1:
                    message.contract = Contract.internalBinaryRead(reader, reader.uint32(), options, message.contract);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeContractsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Contract contract = 1; */
        if (message.contract)
            Contract.internalBinaryWrite(message.contract, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeContractsResponse
 */
export const SubscribeContractsResponse = new SubscribeContractsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldsRequest$Type extends MessageType<WorldsRequest> {
    constructor() {
        super("world.WorldsRequest", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<WorldsRequest>): WorldsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<WorldsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldsRequest): WorldsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldsRequest
 */
export const WorldsRequest = new WorldsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldsResponse$Type extends MessageType<WorldsResponse> {
    constructor() {
        super("world.WorldsResponse", [
            { no: 1, name: "worlds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => World$ }
        ]);
    }
    create(value?: PartialMessage<WorldsResponse>): WorldsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.worlds = [];
        if (value !== undefined)
            reflectionMergePartial<WorldsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldsResponse): WorldsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.World worlds */ 1:
                    message.worlds.push(World$.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.World worlds = 1; */
        for (let i = 0; i < message.worlds.length; i++)
            World$.internalBinaryWrite(message.worlds[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldsResponse
 */
export const WorldsResponse = new WorldsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {
    constructor() {
        super("world.SubscribeEntitiesRequest", [
            { no: 1, name: "clause", kind: "message", T: () => Clause },
            { no: 2, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeEntitiesRequest>): SubscribeEntitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntitiesRequest): SubscribeEntitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                case /* repeated bytes world_addresses */ 2:
                    message.world_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes world_addresses = 2; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntitiesRequest
 */
export const SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {
    constructor() {
        super("world.UpdateEntitiesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "clause", kind: "message", T: () => Clause },
            { no: 3, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateEntitiesSubscriptionRequest>): UpdateEntitiesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.world_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateEntitiesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateEntitiesSubscriptionRequest): UpdateEntitiesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Clause clause */ 2:
                    message.clause = Clause.internalBinaryRead(reader, reader.uint32(), options, message.clause);
                    break;
                case /* repeated bytes world_addresses */ 3:
                    message.world_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateEntitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Clause clause = 2; */
        if (message.clause)
            Clause.internalBinaryWrite(message.clause, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated bytes world_addresses = 3; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export const UpdateEntitiesSubscriptionRequest = new UpdateEntitiesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {
    constructor() {
        super("world.SubscribeEntityResponse", [
            { no: 1, name: "entity", kind: "message", T: () => Entity },
            { no: 2, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeEntityResponse>): SubscribeEntityResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEntityResponse): SubscribeEntityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* uint64 subscription_id */ 2:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 subscription_id = 2; */
        if (message.subscription_id !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.subscription_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntityResponse
 */
export const SubscribeEntityResponse = new SubscribeEntityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {
    constructor() {
        super("world.RetrieveEntitiesRequest", [
            { no: 1, name: "query", kind: "message", T: () => Query }
        ]);
    }
    create(value?: PartialMessage<RetrieveEntitiesRequest>): RetrieveEntitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesRequest): RetrieveEntitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Query query */ 1:
                    message.query = Query.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEntitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesRequest
 */
export const RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {
    constructor() {
        super("world.RetrieveEntitiesResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Entity }
        ]);
    }
    create(value?: PartialMessage<RetrieveEntitiesResponse>): RetrieveEntitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEntitiesResponse): RetrieveEntitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Entity entities */ 2:
                    message.entities.push(Entity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEntitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Entity entities = 2; */
        for (let i = 0; i < message.entities.length; i++)
            Entity.internalBinaryWrite(message.entities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesResponse
 */
export const RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {
    constructor() {
        super("world.RetrieveEventsRequest", [
            { no: 1, name: "query", kind: "message", T: () => EventQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveEventsRequest>): RetrieveEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsRequest): RetrieveEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.EventQuery query */ 1:
                    message.query = EventQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.EventQuery query = 1; */
        if (message.query)
            EventQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsRequest
 */
export const RetrieveEventsRequest = new RetrieveEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {
    constructor() {
        super("world.RetrieveEventsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Event }
        ]);
    }
    create(value?: PartialMessage<RetrieveEventsResponse>): RetrieveEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveEventsResponse): RetrieveEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Event events */ 2:
                    message.events.push(Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(message.events[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsResponse
 */
export const RetrieveEventsResponse = new RetrieveEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor() {
        super("world.SubscribeEventsRequest", [
            { no: 1, name: "keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => KeysClause }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsRequest>): SubscribeEventsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsRequest): SubscribeEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.KeysClause keys */ 1:
                    message.keys.push(KeysClause.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated types.KeysClause keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            KeysClause.internalBinaryWrite(message.keys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsRequest
 */
export const SubscribeEventsRequest = new SubscribeEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor() {
        super("world.SubscribeEventsResponse", [
            { no: 1, name: "event", kind: "message", T: () => Event }
        ]);
    }
    create(value?: PartialMessage<SubscribeEventsResponse>): SubscribeEventsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeEventsResponse): SubscribeEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Event event */ 1:
                    message.event = Event.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.Event event = 1; */
        if (message.event)
            Event.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsResponse
 */
export const SubscribeEventsResponse = new SubscribeEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {
    constructor() {
        super("world.PublishMessageRequest", [
            { no: 1, name: "signature", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "world_address", kind: "scalar", localName: "world_address", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PublishMessageRequest>): PublishMessageRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signature = [];
        message.message = "";
        message.world_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PublishMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageRequest): PublishMessageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes signature */ 1:
                    message.signature.push(reader.bytes());
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* bytes world_address */ 3:
                    message.world_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes signature = 1; */
        for (let i = 0; i < message.signature.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature[i]);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* bytes world_address = 3; */
        if (message.world_address.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.world_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageRequest
 */
export const PublishMessageRequest = new PublishMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {
    constructor() {
        super("world.PublishMessageResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PublishMessageResponse>): PublishMessageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<PublishMessageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageResponse): PublishMessageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageResponse
 */
export const PublishMessageResponse = new PublishMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {
    constructor() {
        super("world.PublishMessageBatchRequest", [
            { no: 1, name: "messages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageRequest }
        ]);
    }
    create(value?: PartialMessage<PublishMessageBatchRequest>): PublishMessageBatchRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchRequest): PublishMessageBatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageRequest messages */ 1:
                    message.messages.push(PublishMessageRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageBatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.PublishMessageRequest messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            PublishMessageRequest.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchRequest
 */
export const PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {
    constructor() {
        super("world.PublishMessageBatchResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PublishMessageResponse }
        ]);
    }
    create(value?: PartialMessage<PublishMessageBatchResponse>): PublishMessageBatchResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.responses = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishMessageBatchResponse): PublishMessageBatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageResponse responses */ 1:
                    message.responses.push(PublishMessageResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishMessageBatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated world.PublishMessageResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            PublishMessageResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchResponse
 */
export const PublishMessageBatchResponse = new PublishMessageBatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenTransfersRequest$Type extends MessageType<SubscribeTokenTransfersRequest> {
    constructor() {
        super("world.SubscribeTokenTransfersRequest", [
            { no: 1, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenTransfersRequest>): SubscribeTokenTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersRequest): SubscribeTokenTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 2:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 2; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersRequest
 */
export const SubscribeTokenTransfersRequest = new SubscribeTokenTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenTransfersResponse$Type extends MessageType<SubscribeTokenTransfersResponse> {
    constructor() {
        super("world.SubscribeTokenTransfersResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "transfer", kind: "message", T: () => TokenTransfer }
        ]);
    }
    create(value?: PartialMessage<SubscribeTokenTransfersResponse>): SubscribeTokenTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeTokenTransfersResponse): SubscribeTokenTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.TokenTransfer transfer */ 2:
                    message.transfer = TokenTransfer.internalBinaryRead(reader, reader.uint32(), options, message.transfer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.TokenTransfer transfer = 2; */
        if (message.transfer)
            TokenTransfer.internalBinaryWrite(message.transfer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenTransfersResponse
 */
export const SubscribeTokenTransfersResponse = new SubscribeTokenTransfersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenTransfersSubscriptionRequest$Type extends MessageType<UpdateTokenTransfersSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenTransfersSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "contract_addresses", kind: "scalar", localName: "contract_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "account_addresses", kind: "scalar", localName: "account_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "token_ids", kind: "scalar", localName: "token_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateTokenTransfersSubscriptionRequest>): UpdateTokenTransfersSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenTransfersSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTokenTransfersSubscriptionRequest): UpdateTokenTransfersSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 3:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 4:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTokenTransfersSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 3; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 4; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenTransfersSubscriptionRequest
 */
export const UpdateTokenTransfersSubscriptionRequest = new UpdateTokenTransfersSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenTransfersRequest$Type extends MessageType<RetrieveTokenTransfersRequest> {
    constructor() {
        super("world.RetrieveTokenTransfersRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenTransferQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenTransfersRequest>): RetrieveTokenTransfersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenTransfersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersRequest): RetrieveTokenTransfersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenTransferQuery query */ 1:
                    message.query = TokenTransferQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenTransfersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.TokenTransferQuery query = 1; */
        if (message.query)
            TokenTransferQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersRequest
 */
export const RetrieveTokenTransfersRequest = new RetrieveTokenTransfersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenTransfersResponse$Type extends MessageType<RetrieveTokenTransfersResponse> {
    constructor() {
        super("world.RetrieveTokenTransfersResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "transfers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TokenTransfer }
        ]);
    }
    create(value?: PartialMessage<RetrieveTokenTransfersResponse>): RetrieveTokenTransfersResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.transfers = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenTransfersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveTokenTransfersResponse): RetrieveTokenTransfersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenTransfer transfers */ 2:
                    message.transfers.push(TokenTransfer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveTokenTransfersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenTransfer transfers = 2; */
        for (let i = 0; i < message.transfers.length; i++)
            TokenTransfer.internalBinaryWrite(message.transfers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenTransfersResponse
 */
export const RetrieveTokenTransfersResponse = new RetrieveTokenTransfersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveAggregationsRequest$Type extends MessageType<RetrieveAggregationsRequest> {
    constructor() {
        super("world.RetrieveAggregationsRequest", [
            { no: 1, name: "query", kind: "message", T: () => AggregationQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveAggregationsRequest>): RetrieveAggregationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveAggregationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAggregationsRequest): RetrieveAggregationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AggregationQuery query */ 1:
                    message.query = AggregationQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveAggregationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AggregationQuery query = 1; */
        if (message.query)
            AggregationQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveAggregationsRequest
 */
export const RetrieveAggregationsRequest = new RetrieveAggregationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveAggregationsResponse$Type extends MessageType<RetrieveAggregationsResponse> {
    constructor() {
        super("world.RetrieveAggregationsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AggregationEntry }
        ]);
    }
    create(value?: PartialMessage<RetrieveAggregationsResponse>): RetrieveAggregationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveAggregationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAggregationsResponse): RetrieveAggregationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.AggregationEntry entries */ 2:
                    message.entries.push(AggregationEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveAggregationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.AggregationEntry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            AggregationEntry.internalBinaryWrite(message.entries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveAggregationsResponse
 */
export const RetrieveAggregationsResponse = new RetrieveAggregationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAggregationsRequest$Type extends MessageType<SubscribeAggregationsRequest> {
    constructor() {
        super("world.SubscribeAggregationsRequest", [
            { no: 1, name: "aggregator_ids", kind: "scalar", localName: "aggregator_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entity_ids", kind: "scalar", localName: "entity_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeAggregationsRequest>): SubscribeAggregationsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.aggregator_ids = [];
        message.entity_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeAggregationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAggregationsRequest): SubscribeAggregationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string aggregator_ids */ 1:
                    message.aggregator_ids.push(reader.string());
                    break;
                case /* repeated string entity_ids */ 2:
                    message.entity_ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeAggregationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string aggregator_ids = 1; */
        for (let i = 0; i < message.aggregator_ids.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.aggregator_ids[i]);
        /* repeated string entity_ids = 2; */
        for (let i = 0; i < message.entity_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.entity_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeAggregationsRequest
 */
export const SubscribeAggregationsRequest = new SubscribeAggregationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAggregationsResponse$Type extends MessageType<SubscribeAggregationsResponse> {
    constructor() {
        super("world.SubscribeAggregationsResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "entry", kind: "message", T: () => AggregationEntry }
        ]);
    }
    create(value?: PartialMessage<SubscribeAggregationsResponse>): SubscribeAggregationsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeAggregationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAggregationsResponse): SubscribeAggregationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.AggregationEntry entry */ 2:
                    message.entry = AggregationEntry.internalBinaryRead(reader, reader.uint32(), options, message.entry);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeAggregationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.AggregationEntry entry = 2; */
        if (message.entry)
            AggregationEntry.internalBinaryWrite(message.entry, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeAggregationsResponse
 */
export const SubscribeAggregationsResponse = new SubscribeAggregationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAggregationsSubscriptionRequest$Type extends MessageType<UpdateAggregationsSubscriptionRequest> {
    constructor() {
        super("world.UpdateAggregationsSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "aggregator_ids", kind: "scalar", localName: "aggregator_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_ids", kind: "scalar", localName: "entity_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateAggregationsSubscriptionRequest>): UpdateAggregationsSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.aggregator_ids = [];
        message.entity_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateAggregationsSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAggregationsSubscriptionRequest): UpdateAggregationsSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated string aggregator_ids */ 2:
                    message.aggregator_ids.push(reader.string());
                    break;
                case /* repeated string entity_ids */ 3:
                    message.entity_ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAggregationsSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated string aggregator_ids = 2; */
        for (let i = 0; i < message.aggregator_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.aggregator_ids[i]);
        /* repeated string entity_ids = 3; */
        for (let i = 0; i < message.entity_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.entity_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateAggregationsSubscriptionRequest
 */
export const UpdateAggregationsSubscriptionRequest = new UpdateAggregationsSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAggregationsSubscriptionResponse$Type extends MessageType<UpdateAggregationsSubscriptionResponse> {
    constructor() {
        super("world.UpdateAggregationsSubscriptionResponse", []);
    }
    create(value?: PartialMessage<UpdateAggregationsSubscriptionResponse>): UpdateAggregationsSubscriptionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateAggregationsSubscriptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAggregationsSubscriptionResponse): UpdateAggregationsSubscriptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAggregationsSubscriptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateAggregationsSubscriptionResponse
 */
export const UpdateAggregationsSubscriptionResponse = new UpdateAggregationsSubscriptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveActivitiesRequest$Type extends MessageType<RetrieveActivitiesRequest> {
    constructor() {
        super("world.RetrieveActivitiesRequest", [
            { no: 1, name: "query", kind: "message", T: () => ActivityQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveActivitiesRequest>): RetrieveActivitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveActivitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveActivitiesRequest): RetrieveActivitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ActivityQuery query */ 1:
                    message.query = ActivityQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveActivitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.ActivityQuery query = 1; */
        if (message.query)
            ActivityQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveActivitiesRequest
 */
export const RetrieveActivitiesRequest = new RetrieveActivitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveActivitiesResponse$Type extends MessageType<RetrieveActivitiesResponse> {
    constructor() {
        super("world.RetrieveActivitiesResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "activities", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Activity }
        ]);
    }
    create(value?: PartialMessage<RetrieveActivitiesResponse>): RetrieveActivitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.activities = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveActivitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveActivitiesResponse): RetrieveActivitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Activity activities */ 2:
                    message.activities.push(Activity.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveActivitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Activity activities = 2; */
        for (let i = 0; i < message.activities.length; i++)
            Activity.internalBinaryWrite(message.activities[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveActivitiesResponse
 */
export const RetrieveActivitiesResponse = new RetrieveActivitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeActivitiesRequest$Type extends MessageType<SubscribeActivitiesRequest> {
    constructor() {
        super("world.SubscribeActivitiesRequest", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "caller_addresses", kind: "scalar", localName: "caller_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeActivitiesRequest>): SubscribeActivitiesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        message.namespaces = [];
        message.caller_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeActivitiesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActivitiesRequest): SubscribeActivitiesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes caller_addresses */ 3:
                    message.caller_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeActivitiesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 2; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes caller_addresses = 3; */
        for (let i = 0; i < message.caller_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeActivitiesRequest
 */
export const SubscribeActivitiesRequest = new SubscribeActivitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeActivitiesResponse$Type extends MessageType<SubscribeActivitiesResponse> {
    constructor() {
        super("world.SubscribeActivitiesResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "activity", kind: "message", T: () => Activity }
        ]);
    }
    create(value?: PartialMessage<SubscribeActivitiesResponse>): SubscribeActivitiesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeActivitiesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeActivitiesResponse): SubscribeActivitiesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Activity activity */ 2:
                    message.activity = Activity.internalBinaryRead(reader, reader.uint32(), options, message.activity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeActivitiesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Activity activity = 2; */
        if (message.activity)
            Activity.internalBinaryWrite(message.activity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeActivitiesResponse
 */
export const SubscribeActivitiesResponse = new SubscribeActivitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateActivitiesSubscriptionRequest$Type extends MessageType<UpdateActivitiesSubscriptionRequest> {
    constructor() {
        super("world.UpdateActivitiesSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "caller_addresses", kind: "scalar", localName: "caller_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateActivitiesSubscriptionRequest>): UpdateActivitiesSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.world_addresses = [];
        message.namespaces = [];
        message.caller_addresses = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateActivitiesSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateActivitiesSubscriptionRequest): UpdateActivitiesSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes world_addresses */ 2:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 3:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes caller_addresses */ 4:
                    message.caller_addresses.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateActivitiesSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes world_addresses = 2; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 3; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes caller_addresses = 4; */
        for (let i = 0; i < message.caller_addresses.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.caller_addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateActivitiesSubscriptionRequest
 */
export const UpdateActivitiesSubscriptionRequest = new UpdateActivitiesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAchievementProgressionsRequest$Type extends MessageType<SubscribeAchievementProgressionsRequest> {
    constructor() {
        super("world.SubscribeAchievementProgressionsRequest", [
            { no: 1, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "player_addresses", kind: "scalar", localName: "player_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "achievement_ids", kind: "scalar", localName: "achievement_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeAchievementProgressionsRequest>): SubscribeAchievementProgressionsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.world_addresses = [];
        message.namespaces = [];
        message.player_addresses = [];
        message.achievement_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeAchievementProgressionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAchievementProgressionsRequest): SubscribeAchievementProgressionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes world_addresses */ 1:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 2:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes player_addresses */ 3:
                    message.player_addresses.push(reader.bytes());
                    break;
                case /* repeated string achievement_ids */ 4:
                    message.achievement_ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeAchievementProgressionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes world_addresses = 1; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 2; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes player_addresses = 3; */
        for (let i = 0; i < message.player_addresses.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.player_addresses[i]);
        /* repeated string achievement_ids = 4; */
        for (let i = 0; i < message.achievement_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.achievement_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeAchievementProgressionsRequest
 */
export const SubscribeAchievementProgressionsRequest = new SubscribeAchievementProgressionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAchievementProgressionsResponse$Type extends MessageType<SubscribeAchievementProgressionsResponse> {
    constructor() {
        super("world.SubscribeAchievementProgressionsResponse", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "progression", kind: "message", T: () => AchievementProgression }
        ]);
    }
    create(value?: PartialMessage<SubscribeAchievementProgressionsResponse>): SubscribeAchievementProgressionsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeAchievementProgressionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAchievementProgressionsResponse): SubscribeAchievementProgressionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.AchievementProgression progression */ 2:
                    message.progression = AchievementProgression.internalBinaryRead(reader, reader.uint32(), options, message.progression);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeAchievementProgressionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.AchievementProgression progression = 2; */
        if (message.progression)
            AchievementProgression.internalBinaryWrite(message.progression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeAchievementProgressionsResponse
 */
export const SubscribeAchievementProgressionsResponse = new SubscribeAchievementProgressionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateAchievementProgressionsSubscriptionRequest$Type extends MessageType<UpdateAchievementProgressionsSubscriptionRequest> {
    constructor() {
        super("world.UpdateAchievementProgressionsSubscriptionRequest", [
            { no: 1, name: "subscription_id", kind: "scalar", localName: "subscription_id", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "world_addresses", kind: "scalar", localName: "world_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "namespaces", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "player_addresses", kind: "scalar", localName: "player_addresses", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "achievement_ids", kind: "scalar", localName: "achievement_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateAchievementProgressionsSubscriptionRequest>): UpdateAchievementProgressionsSubscriptionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subscription_id = 0n;
        message.world_addresses = [];
        message.namespaces = [];
        message.player_addresses = [];
        message.achievement_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateAchievementProgressionsSubscriptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateAchievementProgressionsSubscriptionRequest): UpdateAchievementProgressionsSubscriptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes world_addresses */ 2:
                    message.world_addresses.push(reader.bytes());
                    break;
                case /* repeated string namespaces */ 3:
                    message.namespaces.push(reader.string());
                    break;
                case /* repeated bytes player_addresses */ 4:
                    message.player_addresses.push(reader.bytes());
                    break;
                case /* repeated string achievement_ids */ 5:
                    message.achievement_ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateAchievementProgressionsSubscriptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes world_addresses = 2; */
        for (let i = 0; i < message.world_addresses.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.world_addresses[i]);
        /* repeated string namespaces = 3; */
        for (let i = 0; i < message.namespaces.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.namespaces[i]);
        /* repeated bytes player_addresses = 4; */
        for (let i = 0; i < message.player_addresses.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.player_addresses[i]);
        /* repeated string achievement_ids = 5; */
        for (let i = 0; i < message.achievement_ids.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.achievement_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateAchievementProgressionsSubscriptionRequest
 */
export const UpdateAchievementProgressionsSubscriptionRequest = new UpdateAchievementProgressionsSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveAchievementsRequest$Type extends MessageType<RetrieveAchievementsRequest> {
    constructor() {
        super("world.RetrieveAchievementsRequest", [
            { no: 1, name: "query", kind: "message", T: () => AchievementQuery }
        ]);
    }
    create(value?: PartialMessage<RetrieveAchievementsRequest>): RetrieveAchievementsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrieveAchievementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAchievementsRequest): RetrieveAchievementsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.AchievementQuery query */ 1:
                    message.query = AchievementQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveAchievementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.AchievementQuery query = 1; */
        if (message.query)
            AchievementQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveAchievementsRequest
 */
export const RetrieveAchievementsRequest = new RetrieveAchievementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveAchievementsResponse$Type extends MessageType<RetrieveAchievementsResponse> {
    constructor() {
        super("world.RetrieveAchievementsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "achievements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Achievement }
        ]);
    }
    create(value?: PartialMessage<RetrieveAchievementsResponse>): RetrieveAchievementsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.achievements = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveAchievementsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrieveAchievementsResponse): RetrieveAchievementsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Achievement achievements */ 2:
                    message.achievements.push(Achievement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrieveAchievementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Achievement achievements = 2; */
        for (let i = 0; i < message.achievements.length; i++)
            Achievement.internalBinaryWrite(message.achievements[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveAchievementsResponse
 */
export const RetrieveAchievementsResponse = new RetrieveAchievementsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrievePlayerAchievementsRequest$Type extends MessageType<RetrievePlayerAchievementsRequest> {
    constructor() {
        super("world.RetrievePlayerAchievementsRequest", [
            { no: 1, name: "query", kind: "message", T: () => PlayerAchievementQuery }
        ]);
    }
    create(value?: PartialMessage<RetrievePlayerAchievementsRequest>): RetrievePlayerAchievementsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RetrievePlayerAchievementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrievePlayerAchievementsRequest): RetrievePlayerAchievementsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.PlayerAchievementQuery query */ 1:
                    message.query = PlayerAchievementQuery.internalBinaryRead(reader, reader.uint32(), options, message.query);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrievePlayerAchievementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* types.PlayerAchievementQuery query = 1; */
        if (message.query)
            PlayerAchievementQuery.internalBinaryWrite(message.query, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrievePlayerAchievementsRequest
 */
export const RetrievePlayerAchievementsRequest = new RetrievePlayerAchievementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrievePlayerAchievementsResponse$Type extends MessageType<RetrievePlayerAchievementsResponse> {
    constructor() {
        super("world.RetrievePlayerAchievementsResponse", [
            { no: 1, name: "next_cursor", kind: "scalar", localName: "next_cursor", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerAchievementEntry }
        ]);
    }
    create(value?: PartialMessage<RetrievePlayerAchievementsResponse>): RetrievePlayerAchievementsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.next_cursor = "";
        message.players = [];
        if (value !== undefined)
            reflectionMergePartial<RetrievePlayerAchievementsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RetrievePlayerAchievementsResponse): RetrievePlayerAchievementsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.PlayerAchievementEntry players */ 2:
                    message.players.push(PlayerAchievementEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RetrievePlayerAchievementsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.PlayerAchievementEntry players = 2; */
        for (let i = 0; i < message.players.length; i++)
            PlayerAchievementEntry.internalBinaryWrite(message.players[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrievePlayerAchievementsResponse
 */
export const RetrievePlayerAchievementsResponse = new RetrievePlayerAchievementsResponse$Type();
/**
 * @generated ServiceType for protobuf service world.World
 */
export const World = new ServiceType("world.World", [
    { name: "SubscribeContracts", serverStreaming: true, options: {}, I: SubscribeContractsRequest, O: SubscribeContractsResponse },
    { name: "Worlds", options: {}, I: WorldsRequest, O: WorldsResponse },
    { name: "SubscribeEntities", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
    { name: "UpdateEntitiesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
    { name: "RetrieveEntities", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
    { name: "SubscribeEventMessages", serverStreaming: true, options: {}, I: SubscribeEntitiesRequest, O: SubscribeEntityResponse },
    { name: "UpdateEventMessagesSubscription", options: {}, I: UpdateEntitiesSubscriptionRequest, O: Empty },
    { name: "SubscribeTokenBalances", serverStreaming: true, options: {}, I: SubscribeTokenBalancesRequest, O: SubscribeTokenBalancesResponse },
    { name: "UpdateTokenBalancesSubscription", options: {}, I: UpdateTokenBalancesSubscriptionRequest, O: Empty },
    { name: "SubscribeTokens", serverStreaming: true, options: {}, I: SubscribeTokensRequest, O: SubscribeTokensResponse },
    { name: "UpdateTokensSubscription", options: {}, I: UpdateTokenSubscriptionRequest, O: Empty },
    { name: "SubscribeTokenTransfers", serverStreaming: true, options: {}, I: SubscribeTokenTransfersRequest, O: SubscribeTokenTransfersResponse },
    { name: "UpdateTokenTransfersSubscription", options: {}, I: UpdateTokenTransfersSubscriptionRequest, O: Empty },
    { name: "RetrieveEventMessages", options: {}, I: RetrieveEntitiesRequest, O: RetrieveEntitiesResponse },
    { name: "RetrieveEvents", options: {}, I: RetrieveEventsRequest, O: RetrieveEventsResponse },
    { name: "SubscribeEvents", serverStreaming: true, options: {}, I: SubscribeEventsRequest, O: SubscribeEventsResponse },
    { name: "RetrieveTokens", options: {}, I: RetrieveTokensRequest, O: RetrieveTokensResponse },
    { name: "RetrieveTokenTransfers", options: {}, I: RetrieveTokenTransfersRequest, O: RetrieveTokenTransfersResponse },
    { name: "RetrieveTokenBalances", options: {}, I: RetrieveTokenBalancesRequest, O: RetrieveTokenBalancesResponse },
    { name: "RetrieveTransactions", options: {}, I: RetrieveTransactionsRequest, O: RetrieveTransactionsResponse },
    { name: "SubscribeTransactions", serverStreaming: true, options: {}, I: SubscribeTransactionsRequest, O: SubscribeTransactionsResponse },
    { name: "RetrieveControllers", options: {}, I: RetrieveControllersRequest, O: RetrieveControllersResponse },
    { name: "RetrieveContracts", options: {}, I: RetrieveContractsRequest, O: RetrieveContractsResponse },
    { name: "RetrieveTokenContracts", options: {}, I: RetrieveTokenContractsRequest, O: RetrieveTokenContractsResponse },
    { name: "RetrieveAggregations", options: {}, I: RetrieveAggregationsRequest, O: RetrieveAggregationsResponse },
    { name: "SubscribeAggregations", serverStreaming: true, options: {}, I: SubscribeAggregationsRequest, O: SubscribeAggregationsResponse },
    { name: "UpdateAggregationsSubscription", options: {}, I: UpdateAggregationsSubscriptionRequest, O: UpdateAggregationsSubscriptionResponse },
    { name: "RetrieveActivities", options: {}, I: RetrieveActivitiesRequest, O: RetrieveActivitiesResponse },
    { name: "SubscribeActivities", serverStreaming: true, options: {}, I: SubscribeActivitiesRequest, O: SubscribeActivitiesResponse },
    { name: "UpdateActivitiesSubscription", options: {}, I: UpdateActivitiesSubscriptionRequest, O: Empty },
    { name: "RetrieveAchievements", options: {}, I: RetrieveAchievementsRequest, O: RetrieveAchievementsResponse },
    { name: "RetrievePlayerAchievements", options: {}, I: RetrievePlayerAchievementsRequest, O: RetrievePlayerAchievementsResponse },
    { name: "SubscribeAchievementProgressions", serverStreaming: true, options: {}, I: SubscribeAchievementProgressionsRequest, O: SubscribeAchievementProgressionsResponse },
    { name: "UpdateAchievementProgressionsSubscription", options: {}, I: UpdateAchievementProgressionsSubscriptionRequest, O: Empty },
    { name: "PublishMessage", options: {}, I: PublishMessageRequest, O: PublishMessageResponse },
    { name: "PublishMessageBatch", options: {}, I: PublishMessageBatchRequest, O: PublishMessageBatchResponse },
    { name: "ExecuteSql", options: {}, I: SqlQueryRequest, O: SqlQueryResponse }
]);
