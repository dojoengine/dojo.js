// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies,output_typescript,use_proto_field_name,client_generic
// @generated from protobuf file "world.proto" (package "world", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { KeysClause } from "./types";
import { Event } from "./types";
import { EventQuery } from "./types";
import { Query } from "./types";
import { Entity } from "./types";
import { Clause } from "./types";
import { World as World$ } from "./types";
import { TokenCollection } from "./types";
import { TransactionQuery } from "./types";
import { TokenBalanceQuery } from "./types";
import { Token } from "./types";
import { TokenQuery } from "./types";
import { TokenBalance } from "./types";
import { Controller } from "./types";
import { ControllerQuery } from "./types";
import { Transaction } from "./types";
import { TransactionFilter } from "./types";
/**
 * @generated from protobuf message world.SubscribeTransactionsRequest
 */
export interface SubscribeTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionFilter filter = 1
     */
    filter?: TransactionFilter;
}
/**
 * @generated from protobuf message world.SubscribeTransactionsResponse
 */
export interface SubscribeTransactionsResponse {
    /**
     * @generated from protobuf field: types.Transaction transaction = 1
     */
    transaction?: Transaction;
}
/**
 * @generated from protobuf message world.RetrieveControllersRequest
 */
export interface RetrieveControllersRequest {
    /**
     * @generated from protobuf field: types.ControllerQuery query = 1
     */
    query?: ControllerQuery;
}
/**
 * @generated from protobuf message world.RetrieveControllersResponse
 */
export interface RetrieveControllersResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Controller controllers = 2
     */
    controllers: Controller[];
}
/**
 * A request to update a token balance subscription
 *
 * @generated from protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export interface UpdateTokenBalancesSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 3
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 4
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.SubscribeTokenBalancesResponse
 */
export interface SubscribeTokenBalancesResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token balance
     *
     * @generated from protobuf field: types.TokenBalance balance = 2
     */
    balance?: TokenBalance;
}
/**
 * A request to retrieve tokens
 *
 * @generated from protobuf message world.RetrieveTokensRequest
 */
export interface RetrieveTokensRequest {
    /**
     * @generated from protobuf field: types.TokenQuery query = 1
     */
    query?: TokenQuery;
}
/**
 * A request to subscribe to token updates
 *
 * @generated from protobuf message world.SubscribeTokensRequest
 */
export interface SubscribeTokensRequest {
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 1
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 2
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing tokens
 *
 * @generated from protobuf message world.RetrieveTokensResponse
 */
export interface RetrieveTokensResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Token tokens = 2
     */
    tokens: Token[];
}
/**
 * A response containing token updates
 *
 * @generated from protobuf message world.SubscribeTokensResponse
 */
export interface SubscribeTokensResponse {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The token
     *
     * @generated from protobuf field: types.Token token = 2
     */
    token?: Token;
}
/**
 * A request to update a token subscription
 *
 * @generated from protobuf message world.UpdateTokenSubscriptionRequest
 */
export interface UpdateTokenSubscriptionRequest {
    /**
     * The subscription ID
     *
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * The list of contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A request to retrieve token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesRequest
 */
export interface RetrieveTokenBalancesRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery;
}
/**
 * A request to subscribe to token balance updates
 *
 * @generated from protobuf message world.SubscribeTokenBalancesRequest
 */
export interface SubscribeTokenBalancesRequest {
    /**
     * The account addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes account_addresses = 1
     */
    account_addresses: Uint8Array[];
    /**
     * The list of token contract addresses to subscribe to
     *
     * @generated from protobuf field: repeated bytes contract_addresses = 2
     */
    contract_addresses: Uint8Array[];
    /**
     * The list of token IDs to subscribe to
     *
     * @generated from protobuf field: repeated bytes token_ids = 3
     */
    token_ids: Uint8Array[];
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenBalancesResponse
 */
export interface RetrieveTokenBalancesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenBalance balances = 2
     */
    balances: TokenBalance[];
}
/**
 * A request to retrieve transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsRequest
 */
export interface RetrieveTransactionsRequest {
    /**
     * @generated from protobuf field: types.TransactionQuery query = 1
     */
    query?: TransactionQuery;
}
/**
 * A response containing transactions
 *
 * @generated from protobuf message world.RetrieveTransactionsResponse
 */
export interface RetrieveTransactionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Transaction transactions = 2
     */
    transactions: Transaction[];
}
/**
 * A request to retrieve token collections
 *
 * @generated from protobuf message world.RetrieveTokenCollectionsRequest
 */
export interface RetrieveTokenCollectionsRequest {
    /**
     * @generated from protobuf field: types.TokenBalanceQuery query = 1
     */
    query?: TokenBalanceQuery;
}
/**
 * A response containing token balances
 *
 * @generated from protobuf message world.RetrieveTokenCollectionsResponse
 */
export interface RetrieveTokenCollectionsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.TokenCollection tokens = 2
     */
    tokens: TokenCollection[];
}
/**
 * A request to subscribe to indexer updates.
 *
 * @generated from protobuf message world.SubscribeIndexerRequest
 */
export interface SubscribeIndexerRequest {
    /**
     * @generated from protobuf field: bytes contract_address = 1
     */
    contract_address: Uint8Array;
}
/**
 * A response containing indexer updates.
 *
 * @generated from protobuf message world.SubscribeIndexerResponse
 */
export interface SubscribeIndexerResponse {
    /**
     * @generated from protobuf field: int64 head = 1
     */
    head: bigint;
    /**
     * @generated from protobuf field: int64 tps = 2
     */
    tps: bigint;
    /**
     * @generated from protobuf field: int64 last_block_timestamp = 3
     */
    last_block_timestamp: bigint;
    /**
     * @generated from protobuf field: bytes contract_address = 4
     */
    contract_address: Uint8Array;
}
/**
 * A request to retrieve metadata for a specific world ID.
 *
 * @generated from protobuf message world.WorldMetadataRequest
 */
export interface WorldMetadataRequest {}
/**
 * The metadata response contains addresses and class hashes for the world.
 *
 * @generated from protobuf message world.WorldMetadataResponse
 */
export interface WorldMetadataResponse {
    /**
     * @generated from protobuf field: types.World world = 1
     */
    world?: World$;
}
/**
 * @generated from protobuf message world.SubscribeEntitiesRequest
 */
export interface SubscribeEntitiesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.SubscribeEventMessagesRequest
 */
export interface SubscribeEventMessagesRequest {
    /**
     * @generated from protobuf field: types.Clause clause = 1
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export interface UpdateEntitiesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
export interface UpdateEventMessagesSubscriptionRequest {
    /**
     * @generated from protobuf field: uint64 subscription_id = 1
     */
    subscription_id: bigint;
    /**
     * @generated from protobuf field: types.Clause clause = 2
     */
    clause?: Clause;
}
/**
 * @generated from protobuf message world.SubscribeEntityResponse
 */
export interface SubscribeEntityResponse {
    /**
     * @generated from protobuf field: types.Entity entity = 1
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: uint64 subscription_id = 2
     */
    subscription_id: bigint;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesRequest
 */
export interface RetrieveEntitiesRequest {
    /**
     * The entities to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query;
}
/**
 * @generated from protobuf message world.RetrieveEventMessagesRequest
 */
export interface RetrieveEventMessagesRequest {
    /**
     * The event messages to retrieve
     *
     * @generated from protobuf field: types.Query query = 1
     */
    query?: Query;
}
/**
 * @generated from protobuf message world.RetrieveEntitiesResponse
 */
export interface RetrieveEntitiesResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Entity entities = 2
     */
    entities: Entity[];
}
/**
 * @generated from protobuf message world.RetrieveEventsRequest
 */
export interface RetrieveEventsRequest {
    /**
     * The events to retrieve
     *
     * @generated from protobuf field: types.EventQuery query = 1
     */
    query?: EventQuery;
}
/**
 * @generated from protobuf message world.RetrieveEventsResponse
 */
export interface RetrieveEventsResponse {
    /**
     * @generated from protobuf field: string next_cursor = 1
     */
    next_cursor: string;
    /**
     * @generated from protobuf field: repeated types.Event events = 2
     */
    events: Event[];
}
/**
 * @generated from protobuf message world.SubscribeEventsRequest
 */
export interface SubscribeEventsRequest {
    /**
     * @generated from protobuf field: repeated types.KeysClause keys = 1
     */
    keys: KeysClause[];
}
/**
 * @generated from protobuf message world.SubscribeEventsResponse
 */
export interface SubscribeEventsResponse {
    /**
     * @generated from protobuf field: types.Event event = 1
     */
    event?: Event;
}
/**
 * @generated from protobuf message world.PublishMessageRequest
 */
export interface PublishMessageRequest {
    /**
     * @generated from protobuf field: repeated bytes signature = 1
     */
    signature: Uint8Array[];
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message world.PublishMessageResponse
 */
export interface PublishMessageResponse {
    /**
     * @generated from protobuf field: bytes entity_id = 1
     */
    entity_id: Uint8Array;
}
/**
 * @generated from protobuf message world.PublishMessageBatchRequest
 */
export interface PublishMessageBatchRequest {
    /**
     * @generated from protobuf field: repeated world.PublishMessageRequest messages = 1
     */
    messages: PublishMessageRequest[];
}
/**
 * @generated from protobuf message world.PublishMessageBatchResponse
 */
export interface PublishMessageBatchResponse {
    /**
     * @generated from protobuf field: repeated world.PublishMessageResponse responses = 1
     */
    responses: PublishMessageResponse[];
}
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsRequest$Type extends MessageType<SubscribeTransactionsRequest> {
    constructor() {
        super("world.SubscribeTransactionsRequest", [
            {
                no: 1,
                name: "filter",
                kind: "message",
                T: () => TransactionFilter,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTransactionsRequest>
    ): SubscribeTransactionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTransactionsRequest
    ): SubscribeTransactionsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.filter
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTransactionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(
                message.filter,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsRequest
 */
export const SubscribeTransactionsRequest =
    new SubscribeTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTransactionsResponse$Type extends MessageType<SubscribeTransactionsResponse> {
    constructor() {
        super("world.SubscribeTransactionsResponse", [
            {
                no: 1,
                name: "transaction",
                kind: "message",
                T: () => Transaction,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTransactionsResponse>
    ): SubscribeTransactionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<SubscribeTransactionsResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTransactionsResponse
    ): SubscribeTransactionsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.transaction
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTransactionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(
                message.transaction,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTransactionsResponse
 */
export const SubscribeTransactionsResponse =
    new SubscribeTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersRequest$Type extends MessageType<RetrieveControllersRequest> {
    constructor() {
        super("world.RetrieveControllersRequest", [
            { no: 1, name: "query", kind: "message", T: () => ControllerQuery },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveControllersRequest>
    ): RetrieveControllersRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveControllersRequest
    ): RetrieveControllersRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.ControllerQuery query */ 1:
                    message.query = ControllerQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveControllersRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.ControllerQuery query = 1; */
        if (message.query)
            ControllerQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersRequest
 */
export const RetrieveControllersRequest = new RetrieveControllersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveControllersResponse$Type extends MessageType<RetrieveControllersResponse> {
    constructor() {
        super("world.RetrieveControllersResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "controllers",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Controller,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveControllersResponse>
    ): RetrieveControllersResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.controllers = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveControllersResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveControllersResponse
    ): RetrieveControllersResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Controller controllers */ 2:
                    message.controllers.push(
                        Controller.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveControllersResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Controller controllers = 2; */
        for (let i = 0; i < message.controllers.length; i++)
            Controller.internalBinaryWrite(
                message.controllers[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveControllersResponse
 */
export const RetrieveControllersResponse =
    new RetrieveControllersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenBalancesSubscriptionRequest$Type extends MessageType<UpdateTokenBalancesSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenBalancesSubscriptionRequest", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: "contract_addresses",
                kind: "scalar",
                localName: "contract_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 3,
                name: "account_addresses",
                kind: "scalar",
                localName: "account_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: "token_ids",
                kind: "scalar",
                localName: "token_ids",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<UpdateTokenBalancesSubscriptionRequest>
    ): UpdateTokenBalancesSubscriptionRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.account_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenBalancesSubscriptionRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdateTokenBalancesSubscriptionRequest
    ): UpdateTokenBalancesSubscriptionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes account_addresses */ 3:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 4:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: UpdateTokenBalancesSubscriptionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer
                .tag(2, WireType.LengthDelimited)
                .bytes(message.contract_addresses[i]);
        /* repeated bytes account_addresses = 3; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer
                .tag(3, WireType.LengthDelimited)
                .bytes(message.account_addresses[i]);
        /* repeated bytes token_ids = 4; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(4, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenBalancesSubscriptionRequest
 */
export const UpdateTokenBalancesSubscriptionRequest =
    new UpdateTokenBalancesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesResponse$Type extends MessageType<SubscribeTokenBalancesResponse> {
    constructor() {
        super("world.SubscribeTokenBalancesResponse", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 2, name: "balance", kind: "message", T: () => TokenBalance },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTokenBalancesResponse>
    ): SubscribeTokenBalancesResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTokenBalancesResponse
    ): SubscribeTokenBalancesResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.TokenBalance balance */ 2:
                    message.balance = TokenBalance.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.balance
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTokenBalancesResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.TokenBalance balance = 2; */
        if (message.balance)
            TokenBalance.internalBinaryWrite(
                message.balance,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesResponse
 */
export const SubscribeTokenBalancesResponse =
    new SubscribeTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensRequest$Type extends MessageType<RetrieveTokensRequest> {
    constructor() {
        super("world.RetrieveTokensRequest", [
            { no: 1, name: "query", kind: "message", T: () => TokenQuery },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokensRequest>
    ): RetrieveTokensRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokensRequest
    ): RetrieveTokensRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenQuery query */ 1:
                    message.query = TokenQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokensRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.TokenQuery query = 1; */
        if (message.query)
            TokenQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensRequest
 */
export const RetrieveTokensRequest = new RetrieveTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensRequest$Type extends MessageType<SubscribeTokensRequest> {
    constructor() {
        super("world.SubscribeTokensRequest", [
            {
                no: 1,
                name: "contract_addresses",
                kind: "scalar",
                localName: "contract_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: "token_ids",
                kind: "scalar",
                localName: "token_ids",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTokensRequest>
    ): SubscribeTokensRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTokensRequest
    ): SubscribeTokensRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes contract_addresses */ 1:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 2:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTokensRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated bytes contract_addresses = 1; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 2; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensRequest
 */
export const SubscribeTokensRequest = new SubscribeTokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokensResponse$Type extends MessageType<RetrieveTokensResponse> {
    constructor() {
        super("world.RetrieveTokensResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "tokens",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Token,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokensResponse>
    ): RetrieveTokensResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokensResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokensResponse
    ): RetrieveTokensResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Token tokens */ 2:
                    message.tokens.push(
                        Token.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokensResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Token tokens = 2; */
        for (let i = 0; i < message.tokens.length; i++)
            Token.internalBinaryWrite(
                message.tokens[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokensResponse
 */
export const RetrieveTokensResponse = new RetrieveTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokensResponse$Type extends MessageType<SubscribeTokensResponse> {
    constructor() {
        super("world.SubscribeTokensResponse", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 2, name: "token", kind: "message", T: () => Token },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTokensResponse>
    ): SubscribeTokensResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokensResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTokensResponse
    ): SubscribeTokensResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Token token */ 2:
                    message.token = Token.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.token
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTokensResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Token token = 2; */
        if (message.token)
            Token.internalBinaryWrite(
                message.token,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokensResponse
 */
export const SubscribeTokensResponse = new SubscribeTokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTokenSubscriptionRequest$Type extends MessageType<UpdateTokenSubscriptionRequest> {
    constructor() {
        super("world.UpdateTokenSubscriptionRequest", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: "contract_addresses",
                kind: "scalar",
                localName: "contract_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 3,
                name: "token_ids",
                kind: "scalar",
                localName: "token_ids",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<UpdateTokenSubscriptionRequest>
    ): UpdateTokenSubscriptionRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateTokenSubscriptionRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdateTokenSubscriptionRequest
    ): UpdateTokenSubscriptionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: UpdateTokenSubscriptionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer
                .tag(2, WireType.LengthDelimited)
                .bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateTokenSubscriptionRequest
 */
export const UpdateTokenSubscriptionRequest =
    new UpdateTokenSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesRequest$Type extends MessageType<RetrieveTokenBalancesRequest> {
    constructor() {
        super("world.RetrieveTokenBalancesRequest", [
            {
                no: 1,
                name: "query",
                kind: "message",
                T: () => TokenBalanceQuery,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokenBalancesRequest>
    ): RetrieveTokenBalancesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokenBalancesRequest
    ): RetrieveTokenBalancesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenBalanceQuery query */ 1:
                    message.query = TokenBalanceQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokenBalancesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.TokenBalanceQuery query = 1; */
        if (message.query)
            TokenBalanceQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesRequest
 */
export const RetrieveTokenBalancesRequest =
    new RetrieveTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeTokenBalancesRequest$Type extends MessageType<SubscribeTokenBalancesRequest> {
    constructor() {
        super("world.SubscribeTokenBalancesRequest", [
            {
                no: 1,
                name: "account_addresses",
                kind: "scalar",
                localName: "account_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: "contract_addresses",
                kind: "scalar",
                localName: "contract_addresses",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 3,
                name: "token_ids",
                kind: "scalar",
                localName: "token_ids",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeTokenBalancesRequest>
    ): SubscribeTokenBalancesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.account_addresses = [];
        message.contract_addresses = [];
        message.token_ids = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeTokenBalancesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeTokenBalancesRequest
    ): SubscribeTokenBalancesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes account_addresses */ 1:
                    message.account_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes contract_addresses */ 2:
                    message.contract_addresses.push(reader.bytes());
                    break;
                case /* repeated bytes token_ids */ 3:
                    message.token_ids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeTokenBalancesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated bytes account_addresses = 1; */
        for (let i = 0; i < message.account_addresses.length; i++)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.account_addresses[i]);
        /* repeated bytes contract_addresses = 2; */
        for (let i = 0; i < message.contract_addresses.length; i++)
            writer
                .tag(2, WireType.LengthDelimited)
                .bytes(message.contract_addresses[i]);
        /* repeated bytes token_ids = 3; */
        for (let i = 0; i < message.token_ids.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.token_ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeTokenBalancesRequest
 */
export const SubscribeTokenBalancesRequest =
    new SubscribeTokenBalancesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenBalancesResponse$Type extends MessageType<RetrieveTokenBalancesResponse> {
    constructor() {
        super("world.RetrieveTokenBalancesResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "balances",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TokenBalance,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokenBalancesResponse>
    ): RetrieveTokenBalancesResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.balances = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenBalancesResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokenBalancesResponse
    ): RetrieveTokenBalancesResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenBalance balances */ 2:
                    message.balances.push(
                        TokenBalance.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokenBalancesResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenBalance balances = 2; */
        for (let i = 0; i < message.balances.length; i++)
            TokenBalance.internalBinaryWrite(
                message.balances[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenBalancesResponse
 */
export const RetrieveTokenBalancesResponse =
    new RetrieveTokenBalancesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsRequest$Type extends MessageType<RetrieveTransactionsRequest> {
    constructor() {
        super("world.RetrieveTransactionsRequest", [
            {
                no: 1,
                name: "query",
                kind: "message",
                T: () => TransactionQuery,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTransactionsRequest>
    ): RetrieveTransactionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTransactionsRequest
    ): RetrieveTransactionsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TransactionQuery query */ 1:
                    message.query = TransactionQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTransactionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.TransactionQuery query = 1; */
        if (message.query)
            TransactionQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsRequest
 */
export const RetrieveTransactionsRequest =
    new RetrieveTransactionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTransactionsResponse$Type extends MessageType<RetrieveTransactionsResponse> {
    constructor() {
        super("world.RetrieveTransactionsResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "transactions",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Transaction,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTransactionsResponse>
    ): RetrieveTransactionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.transactions = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTransactionsResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTransactionsResponse
    ): RetrieveTransactionsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Transaction transactions */ 2:
                    message.transactions.push(
                        Transaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTransactionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(
                message.transactions[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTransactionsResponse
 */
export const RetrieveTransactionsResponse =
    new RetrieveTransactionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenCollectionsRequest$Type extends MessageType<RetrieveTokenCollectionsRequest> {
    constructor() {
        super("world.RetrieveTokenCollectionsRequest", [
            {
                no: 1,
                name: "query",
                kind: "message",
                T: () => TokenBalanceQuery,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokenCollectionsRequest>
    ): RetrieveTokenCollectionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenCollectionsRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokenCollectionsRequest
    ): RetrieveTokenCollectionsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.TokenBalanceQuery query */ 1:
                    message.query = TokenBalanceQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokenCollectionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.TokenBalanceQuery query = 1; */
        if (message.query)
            TokenBalanceQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenCollectionsRequest
 */
export const RetrieveTokenCollectionsRequest =
    new RetrieveTokenCollectionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveTokenCollectionsResponse$Type extends MessageType<RetrieveTokenCollectionsResponse> {
    constructor() {
        super("world.RetrieveTokenCollectionsResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "tokens",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TokenCollection,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveTokenCollectionsResponse>
    ): RetrieveTokenCollectionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.tokens = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveTokenCollectionsResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveTokenCollectionsResponse
    ): RetrieveTokenCollectionsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.TokenCollection tokens */ 2:
                    message.tokens.push(
                        TokenCollection.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveTokenCollectionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.TokenCollection tokens = 2; */
        for (let i = 0; i < message.tokens.length; i++)
            TokenCollection.internalBinaryWrite(
                message.tokens[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveTokenCollectionsResponse
 */
export const RetrieveTokenCollectionsResponse =
    new RetrieveTokenCollectionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeIndexerRequest$Type extends MessageType<SubscribeIndexerRequest> {
    constructor() {
        super("world.SubscribeIndexerRequest", [
            {
                no: 1,
                name: "contract_address",
                kind: "scalar",
                localName: "contract_address",
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeIndexerRequest>
    ): SubscribeIndexerRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.contract_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubscribeIndexerRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeIndexerRequest
    ): SubscribeIndexerRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes contract_address */ 1:
                    message.contract_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeIndexerRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes contract_address = 1; */
        if (message.contract_address.length)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.contract_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeIndexerRequest
 */
export const SubscribeIndexerRequest = new SubscribeIndexerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeIndexerResponse$Type extends MessageType<SubscribeIndexerResponse> {
    constructor() {
        super("world.SubscribeIndexerResponse", [
            {
                no: 1,
                name: "head",
                kind: "scalar",
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: "tps",
                kind: "scalar",
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 3,
                name: "last_block_timestamp",
                kind: "scalar",
                localName: "last_block_timestamp",
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 4,
                name: "contract_address",
                kind: "scalar",
                localName: "contract_address",
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeIndexerResponse>
    ): SubscribeIndexerResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.head = 0n;
        message.tps = 0n;
        message.last_block_timestamp = 0n;
        message.contract_address = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SubscribeIndexerResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeIndexerResponse
    ): SubscribeIndexerResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 head */ 1:
                    message.head = reader.int64().toBigInt();
                    break;
                case /* int64 tps */ 2:
                    message.tps = reader.int64().toBigInt();
                    break;
                case /* int64 last_block_timestamp */ 3:
                    message.last_block_timestamp = reader.int64().toBigInt();
                    break;
                case /* bytes contract_address */ 4:
                    message.contract_address = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeIndexerResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 head = 1; */
        if (message.head !== 0n)
            writer.tag(1, WireType.Varint).int64(message.head);
        /* int64 tps = 2; */
        if (message.tps !== 0n)
            writer.tag(2, WireType.Varint).int64(message.tps);
        /* int64 last_block_timestamp = 3; */
        if (message.last_block_timestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.last_block_timestamp);
        /* bytes contract_address = 4; */
        if (message.contract_address.length)
            writer
                .tag(4, WireType.LengthDelimited)
                .bytes(message.contract_address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeIndexerResponse
 */
export const SubscribeIndexerResponse = new SubscribeIndexerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldMetadataRequest$Type extends MessageType<WorldMetadataRequest> {
    constructor() {
        super("world.WorldMetadataRequest", []);
    }
    create(value?: PartialMessage<WorldMetadataRequest>): WorldMetadataRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<WorldMetadataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: WorldMetadataRequest
    ): WorldMetadataRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: WorldMetadataRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataRequest
 */
export const WorldMetadataRequest = new WorldMetadataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldMetadataResponse$Type extends MessageType<WorldMetadataResponse> {
    constructor() {
        super("world.WorldMetadataResponse", [
            { no: 1, name: "world", kind: "message", T: () => World$ },
        ]);
    }
    create(
        value?: PartialMessage<WorldMetadataResponse>
    ): WorldMetadataResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<WorldMetadataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: WorldMetadataResponse
    ): WorldMetadataResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.World world */ 1:
                    message.world = World$.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.world
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: WorldMetadataResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.World world = 1; */
        if (message.world)
            World$.internalBinaryWrite(
                message.world,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.WorldMetadataResponse
 */
export const WorldMetadataResponse = new WorldMetadataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntitiesRequest$Type extends MessageType<SubscribeEntitiesRequest> {
    constructor() {
        super("world.SubscribeEntitiesRequest", [
            { no: 1, name: "clause", kind: "message", T: () => Clause },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeEntitiesRequest>
    ): SubscribeEntitiesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntitiesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeEntitiesRequest
    ): SubscribeEntitiesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.clause
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeEntitiesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(
                message.clause,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntitiesRequest
 */
export const SubscribeEntitiesRequest = new SubscribeEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventMessagesRequest$Type extends MessageType<SubscribeEventMessagesRequest> {
    constructor() {
        super("world.SubscribeEventMessagesRequest", [
            { no: 1, name: "clause", kind: "message", T: () => Clause },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeEventMessagesRequest>
    ): SubscribeEventMessagesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventMessagesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeEventMessagesRequest
    ): SubscribeEventMessagesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Clause clause */ 1:
                    message.clause = Clause.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.clause
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeEventMessagesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Clause clause = 1; */
        if (message.clause)
            Clause.internalBinaryWrite(
                message.clause,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventMessagesRequest
 */
export const SubscribeEventMessagesRequest =
    new SubscribeEventMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEntitiesSubscriptionRequest$Type extends MessageType<UpdateEntitiesSubscriptionRequest> {
    constructor() {
        super("world.UpdateEntitiesSubscriptionRequest", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 2, name: "clause", kind: "message", T: () => Clause },
        ]);
    }
    create(
        value?: PartialMessage<UpdateEntitiesSubscriptionRequest>
    ): UpdateEntitiesSubscriptionRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateEntitiesSubscriptionRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdateEntitiesSubscriptionRequest
    ): UpdateEntitiesSubscriptionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Clause clause */ 2:
                    message.clause = Clause.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.clause
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: UpdateEntitiesSubscriptionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Clause clause = 2; */
        if (message.clause)
            Clause.internalBinaryWrite(
                message.clause,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateEntitiesSubscriptionRequest
 */
export const UpdateEntitiesSubscriptionRequest =
    new UpdateEntitiesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateEventMessagesSubscriptionRequest$Type extends MessageType<UpdateEventMessagesSubscriptionRequest> {
    constructor() {
        super("world.UpdateEventMessagesSubscriptionRequest", [
            {
                no: 1,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            { no: 2, name: "clause", kind: "message", T: () => Clause },
        ]);
    }
    create(
        value?: PartialMessage<UpdateEventMessagesSubscriptionRequest>
    ): UpdateEventMessagesSubscriptionRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<UpdateEventMessagesSubscriptionRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdateEventMessagesSubscriptionRequest
    ): UpdateEventMessagesSubscriptionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 subscription_id */ 1:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                case /* types.Clause clause */ 2:
                    message.clause = Clause.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.clause
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: UpdateEventMessagesSubscriptionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* uint64 subscription_id = 1; */
        if (message.subscription_id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.subscription_id);
        /* types.Clause clause = 2; */
        if (message.clause)
            Clause.internalBinaryWrite(
                message.clause,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.UpdateEventMessagesSubscriptionRequest
 */
export const UpdateEventMessagesSubscriptionRequest =
    new UpdateEventMessagesSubscriptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEntityResponse$Type extends MessageType<SubscribeEntityResponse> {
    constructor() {
        super("world.SubscribeEntityResponse", [
            { no: 1, name: "entity", kind: "message", T: () => Entity },
            {
                no: 2,
                name: "subscription_id",
                kind: "scalar",
                localName: "subscription_id",
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeEntityResponse>
    ): SubscribeEntityResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.subscription_id = 0n;
        if (value !== undefined)
            reflectionMergePartial<SubscribeEntityResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeEntityResponse
    ): SubscribeEntityResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.entity
                    );
                    break;
                case /* uint64 subscription_id */ 2:
                    message.subscription_id = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeEntityResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(
                message.entity,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        /* uint64 subscription_id = 2; */
        if (message.subscription_id !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.subscription_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEntityResponse
 */
export const SubscribeEntityResponse = new SubscribeEntityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesRequest$Type extends MessageType<RetrieveEntitiesRequest> {
    constructor() {
        super("world.RetrieveEntitiesRequest", [
            { no: 1, name: "query", kind: "message", T: () => Query },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveEntitiesRequest>
    ): RetrieveEntitiesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveEntitiesRequest
    ): RetrieveEntitiesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Query query */ 1:
                    message.query = Query.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveEntitiesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesRequest
 */
export const RetrieveEntitiesRequest = new RetrieveEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventMessagesRequest$Type extends MessageType<RetrieveEventMessagesRequest> {
    constructor() {
        super("world.RetrieveEventMessagesRequest", [
            { no: 1, name: "query", kind: "message", T: () => Query },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveEventMessagesRequest>
    ): RetrieveEventMessagesRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventMessagesRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveEventMessagesRequest
    ): RetrieveEventMessagesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Query query */ 1:
                    message.query = Query.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveEventMessagesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Query query = 1; */
        if (message.query)
            Query.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventMessagesRequest
 */
export const RetrieveEventMessagesRequest =
    new RetrieveEventMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEntitiesResponse$Type extends MessageType<RetrieveEntitiesResponse> {
    constructor() {
        super("world.RetrieveEntitiesResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "entities",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Entity,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveEntitiesResponse>
    ): RetrieveEntitiesResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.entities = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEntitiesResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveEntitiesResponse
    ): RetrieveEntitiesResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Entity entities */ 2:
                    message.entities.push(
                        Entity.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveEntitiesResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Entity entities = 2; */
        for (let i = 0; i < message.entities.length; i++)
            Entity.internalBinaryWrite(
                message.entities[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEntitiesResponse
 */
export const RetrieveEntitiesResponse = new RetrieveEntitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsRequest$Type extends MessageType<RetrieveEventsRequest> {
    constructor() {
        super("world.RetrieveEventsRequest", [
            { no: 1, name: "query", kind: "message", T: () => EventQuery },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveEventsRequest>
    ): RetrieveEventsRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveEventsRequest
    ): RetrieveEventsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.EventQuery query */ 1:
                    message.query = EventQuery.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.query
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveEventsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.EventQuery query = 1; */
        if (message.query)
            EventQuery.internalBinaryWrite(
                message.query,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsRequest
 */
export const RetrieveEventsRequest = new RetrieveEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RetrieveEventsResponse$Type extends MessageType<RetrieveEventsResponse> {
    constructor() {
        super("world.RetrieveEventsResponse", [
            {
                no: 1,
                name: "next_cursor",
                kind: "scalar",
                localName: "next_cursor",
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: "events",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Event,
            },
        ]);
    }
    create(
        value?: PartialMessage<RetrieveEventsResponse>
    ): RetrieveEventsResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.next_cursor = "";
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<RetrieveEventsResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RetrieveEventsResponse
    ): RetrieveEventsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string next_cursor */ 1:
                    message.next_cursor = reader.string();
                    break;
                case /* repeated types.Event events */ 2:
                    message.events.push(
                        Event.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: RetrieveEventsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string next_cursor = 1; */
        if (message.next_cursor !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.next_cursor);
        /* repeated types.Event events = 2; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(
                message.events[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.RetrieveEventsResponse
 */
export const RetrieveEventsResponse = new RetrieveEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsRequest$Type extends MessageType<SubscribeEventsRequest> {
    constructor() {
        super("world.SubscribeEventsRequest", [
            {
                no: 1,
                name: "keys",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => KeysClause,
            },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeEventsRequest>
    ): SubscribeEventsRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeEventsRequest
    ): SubscribeEventsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated types.KeysClause keys */ 1:
                    message.keys.push(
                        KeysClause.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeEventsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated types.KeysClause keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            KeysClause.internalBinaryWrite(
                message.keys[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsRequest
 */
export const SubscribeEventsRequest = new SubscribeEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeEventsResponse$Type extends MessageType<SubscribeEventsResponse> {
    constructor() {
        super("world.SubscribeEventsResponse", [
            { no: 1, name: "event", kind: "message", T: () => Event },
        ]);
    }
    create(
        value?: PartialMessage<SubscribeEventsResponse>
    ): SubscribeEventsResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        if (value !== undefined)
            reflectionMergePartial<SubscribeEventsResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubscribeEventsResponse
    ): SubscribeEventsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* types.Event event */ 1:
                    message.event = Event.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.event
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: SubscribeEventsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* types.Event event = 1; */
        if (message.event)
            Event.internalBinaryWrite(
                message.event,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.SubscribeEventsResponse
 */
export const SubscribeEventsResponse = new SubscribeEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageRequest$Type extends MessageType<PublishMessageRequest> {
    constructor() {
        super("world.PublishMessageRequest", [
            {
                no: 1,
                name: "signature",
                kind: "scalar",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: "message",
                kind: "scalar",
                T: 9 /*ScalarType.STRING*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<PublishMessageRequest>
    ): PublishMessageRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.signature = [];
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<PublishMessageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublishMessageRequest
    ): PublishMessageRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes signature */ 1:
                    message.signature.push(reader.bytes());
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: PublishMessageRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated bytes signature = 1; */
        for (let i = 0; i < message.signature.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.signature[i]);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageRequest
 */
export const PublishMessageRequest = new PublishMessageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageResponse$Type extends MessageType<PublishMessageResponse> {
    constructor() {
        super("world.PublishMessageResponse", [
            {
                no: 1,
                name: "entity_id",
                kind: "scalar",
                localName: "entity_id",
                T: 12 /*ScalarType.BYTES*/,
            },
        ]);
    }
    create(
        value?: PartialMessage<PublishMessageResponse>
    ): PublishMessageResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.entity_id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PublishMessageResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublishMessageResponse
    ): PublishMessageResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes entity_id */ 1:
                    message.entity_id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: PublishMessageResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes entity_id = 1; */
        if (message.entity_id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.entity_id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageResponse
 */
export const PublishMessageResponse = new PublishMessageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchRequest$Type extends MessageType<PublishMessageBatchRequest> {
    constructor() {
        super("world.PublishMessageBatchRequest", [
            {
                no: 1,
                name: "messages",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PublishMessageRequest,
            },
        ]);
    }
    create(
        value?: PartialMessage<PublishMessageBatchRequest>
    ): PublishMessageBatchRequest {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.messages = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchRequest>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublishMessageBatchRequest
    ): PublishMessageBatchRequest {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageRequest messages */ 1:
                    message.messages.push(
                        PublishMessageRequest.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: PublishMessageBatchRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated world.PublishMessageRequest messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            PublishMessageRequest.internalBinaryWrite(
                message.messages[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchRequest
 */
export const PublishMessageBatchRequest = new PublishMessageBatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishMessageBatchResponse$Type extends MessageType<PublishMessageBatchResponse> {
    constructor() {
        super("world.PublishMessageBatchResponse", [
            {
                no: 1,
                name: "responses",
                kind: "message",
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PublishMessageResponse,
            },
        ]);
    }
    create(
        value?: PartialMessage<PublishMessageBatchResponse>
    ): PublishMessageBatchResponse {
        const message = globalThis.Object.create(this.messagePrototype!);
        message.responses = [];
        if (value !== undefined)
            reflectionMergePartial<PublishMessageBatchResponse>(
                this,
                message,
                value
            );
        return message;
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublishMessageBatchResponse
    ): PublishMessageBatchResponse {
        let message = target ?? this.create(),
            end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated world.PublishMessageResponse responses */ 1:
                    message.responses.push(
                        PublishMessageResponse.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    );
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        );
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        );
            }
        }
        return message;
    }
    internalBinaryWrite(
        message: PublishMessageBatchResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated world.PublishMessageResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            PublishMessageResponse.internalBinaryWrite(
                message.responses[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            );
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message world.PublishMessageBatchResponse
 */
export const PublishMessageBatchResponse =
    new PublishMessageBatchResponse$Type();
/**
 * @generated ServiceType for protobuf service world.World
 */
export const World = new ServiceType("world.World", [
    {
        name: "SubscribeIndexer",
        serverStreaming: true,
        options: {},
        I: SubscribeIndexerRequest,
        O: SubscribeIndexerResponse,
    },
    {
        name: "WorldMetadata",
        options: {},
        I: WorldMetadataRequest,
        O: WorldMetadataResponse,
    },
    {
        name: "SubscribeEntities",
        serverStreaming: true,
        options: {},
        I: SubscribeEntitiesRequest,
        O: SubscribeEntityResponse,
    },
    {
        name: "UpdateEntitiesSubscription",
        options: {},
        I: UpdateEntitiesSubscriptionRequest,
        O: Empty,
    },
    {
        name: "RetrieveEntities",
        options: {},
        I: RetrieveEntitiesRequest,
        O: RetrieveEntitiesResponse,
    },
    {
        name: "SubscribeEventMessages",
        serverStreaming: true,
        options: {},
        I: SubscribeEventMessagesRequest,
        O: SubscribeEntityResponse,
    },
    {
        name: "UpdateEventMessagesSubscription",
        options: {},
        I: UpdateEventMessagesSubscriptionRequest,
        O: Empty,
    },
    {
        name: "SubscribeTokenBalances",
        serverStreaming: true,
        options: {},
        I: SubscribeTokenBalancesRequest,
        O: SubscribeTokenBalancesResponse,
    },
    {
        name: "UpdateTokenBalancesSubscription",
        options: {},
        I: UpdateTokenBalancesSubscriptionRequest,
        O: Empty,
    },
    {
        name: "SubscribeTokens",
        serverStreaming: true,
        options: {},
        I: SubscribeTokensRequest,
        O: SubscribeTokensResponse,
    },
    {
        name: "UpdateTokensSubscription",
        options: {},
        I: UpdateTokenSubscriptionRequest,
        O: Empty,
    },
    {
        name: "RetrieveEventMessages",
        options: {},
        I: RetrieveEventMessagesRequest,
        O: RetrieveEntitiesResponse,
    },
    {
        name: "RetrieveEvents",
        options: {},
        I: RetrieveEventsRequest,
        O: RetrieveEventsResponse,
    },
    {
        name: "SubscribeEvents",
        serverStreaming: true,
        options: {},
        I: SubscribeEventsRequest,
        O: SubscribeEventsResponse,
    },
    {
        name: "RetrieveTokens",
        options: {},
        I: RetrieveTokensRequest,
        O: RetrieveTokensResponse,
    },
    {
        name: "RetrieveTokenBalances",
        options: {},
        I: RetrieveTokenBalancesRequest,
        O: RetrieveTokenBalancesResponse,
    },
    {
        name: "RetrieveTransactions",
        options: {},
        I: RetrieveTransactionsRequest,
        O: RetrieveTransactionsResponse,
    },
    {
        name: "SubscribeTransactions",
        serverStreaming: true,
        options: {},
        I: SubscribeTransactionsRequest,
        O: SubscribeTransactionsResponse,
    },
    {
        name: "RetrieveControllers",
        options: {},
        I: RetrieveControllersRequest,
        O: RetrieveControllersResponse,
    },
    {
        name: "RetrieveTokenCollections",
        options: {},
        I: RetrieveTokenCollectionsRequest,
        O: RetrieveTokenCollectionsResponse,
    },
    {
        name: "PublishMessage",
        options: {},
        I: PublishMessageRequest,
        O: PublishMessageResponse,
    },
    {
        name: "PublishMessageBatch",
        options: {},
        I: PublishMessageBatchRequest,
        O: PublishMessageBatchResponse,
    },
]);
