syntax = "proto3";
package types;

import "schema.proto";

message World {
    // The hex-encoded address of the world.
    string world_address = 1;
    // A list of metadata for all registered components in the world.
    repeated Model models = 2;
}

message Model {
    // Model selector
    bytes selector = 1;
    // Model namespace
    string namespace = 2;
    // Model name
    string name = 3;
    // Model size when it is packed for storage
    uint32 packed_size = 4;
    // Model size when it is unpacked
    uint32 unpacked_size = 5;
    // felt bytes of the class hash of the component
    bytes class_hash = 6;
    // The layout of the component in bytes
    bytes layout = 7;
    // The schema of the component serialized in bytes (for simplicity sake)
    bytes schema = 8;
    // felt bytes of the contract address of the component
    bytes contract_address = 9;
    bool use_legacy_store = 10;
    // The world address of the model
    bytes world_address = 11;
}

message Entity {
    // The entity's hashed keys
    bytes hashed_keys = 1;
    // Models of the entity
    repeated Struct models = 2;
    // Created at timestamp
    uint64 created_at = 3;
    // Updated at timestamp
    uint64 updated_at = 4;
    // Block timestamp when the entity was updated
    uint64 executed_at = 5;
    // The world address of the entity
    bytes world_address = 6;
}

message Event {
    // The event's keys
    repeated bytes keys = 1;
    // Data of the event
    repeated bytes data = 2;
    // event's transaction hash
    bytes transaction_hash = 3;
}

message Query {
    Clause clause = 1;
    bool no_hashed_keys = 2;
    repeated string models = 3;
    Pagination pagination = 4;
    bool historical = 5;
    repeated bytes world_addresses = 6;
}

message EventQuery {
    KeysClause keys = 1;
    Pagination pagination = 2;
}

message Clause {
    oneof clause_type {
        HashedKeysClause hashed_keys = 1;
        KeysClause keys = 2;
        MemberClause member = 3;
        CompositeClause composite = 4;
    }
}

message KeysClause {
    repeated bytes keys = 2;
    PatternMatching pattern_matching = 3;
    repeated string models = 4;
}

message HashedKeysClause {
    repeated bytes hashed_keys = 1;
}

message MemberValue {
    oneof value_type {
        Primitive primitive = 1;
        string string = 2;
        MemberValueList list = 3;
    }
}

message MemberValueList {
    repeated MemberValue values = 1;
}

message MemberClause {
    string model = 2;
    string member = 3;
    ComparisonOperator operator = 4;
    MemberValue value = 5;
}

message CompositeClause {
    LogicalOperator operator = 3;
    repeated Clause clauses = 4;
}

enum PatternMatching {
    FixedLen = 0;
    VariableLen = 1;
}

enum LogicalOperator {
    AND = 0;
    OR = 1;
}

enum ComparisonOperator {
    EQ = 0;
    NEQ = 1;
    GT = 2;
    GTE = 3;
    LT = 4;
    LTE = 5;
    IN = 6;
    NOT_IN = 7;
    // Array-specific operators
    CONTAINS = 8;           // Array contains value
    CONTAINS_ALL = 9;       // Array contains all values
    CONTAINS_ANY = 10;      // Array contains any of the values
    ARRAY_LENGTH_EQ = 11;   // Array length equals
    ARRAY_LENGTH_GT = 12;   // Array length greater than
    ARRAY_LENGTH_LT = 13;   // Array length less than
}

message Token {
    optional bytes token_id = 1;
    bytes contract_address = 2;
    string name = 3;
    string symbol = 4;
    uint32 decimals = 5;
    bytes metadata = 6;
    optional bytes total_supply = 7;
}

message TokenBalance {
    bytes balance = 1;
    bytes account_address = 2;
    bytes contract_address = 3;
    optional bytes token_id = 4;
}

message OrderBy {
    string field = 1;
    OrderDirection direction = 2;
}

enum OrderDirection {
    ASC = 0;
    DESC = 1;
}

message Controller {
    bytes address = 1;
    string username = 2;
    uint64 deployed_at_timestamp = 3;
}

enum PaginationDirection {
    FORWARD = 0;
    BACKWARD = 1;
}

message Pagination {
    string cursor = 1;
    uint32 limit = 2;
    PaginationDirection direction = 3;
    repeated OrderBy order_by = 4;
}

message ControllerQuery {
    // The list of contract addresses to retrieve controllers for
    repeated bytes contract_addresses = 1;
    // The list of usernames to retrieve controllers for
    repeated string usernames = 2;
    // Pagination
    Pagination pagination = 3;
}

// Token attribute filter for filtering tokens by their metadata attributes
message TokenAttributeFilter {
    // The name of the trait/attribute to filter by
    string trait_name = 1;
    // The value of the trait/attribute to filter by
    string trait_value = 2;
}

// A request to retrieve tokens
message TokenQuery {
    // The list of contract addresses to retrieve tokens for
    repeated bytes contract_addresses = 1;
    // The list of token IDs to retrieve tokens for
    repeated bytes token_ids = 2;
    // The list of attribute filters to apply
    repeated TokenAttributeFilter attribute_filters = 3;
    // Pagination
    Pagination pagination = 4;
}

// A request to retrieve token balances
message TokenBalanceQuery {
    // The account addresses to retrieve balances for
    repeated bytes account_addresses = 1;
    // The list of token contract addresses to retrieve balances for
    repeated bytes contract_addresses = 2;
    // The list of token IDs to retrieve balances for
    repeated bytes token_ids = 3;
    // Pagination
    Pagination pagination = 4;
}

// A request to retrieve token contracts
message TokenContractQuery {
    // The list of contract addresses to retrieve token contracts for
    repeated bytes contract_addresses = 1;
    // The list of contract types to filter by
    repeated ContractType contract_types = 2;
    // Pagination
    Pagination pagination = 3;
}

// A token transfer record
message TokenTransfer {
    // Unique identifier for the transfer (event_id:token_id key)
    string id = 1;
    // Contract address of the token
    bytes contract_address = 2;
    // Sender address
    bytes from_address = 3;
    // Recipient address
    bytes to_address = 4;
    // Amount transferred (big-endian bytes)
    bytes amount = 5;
    // Token ID when applicable (ERC721/1155); omitted for ERC20
    optional bytes token_id = 6;
    // Executed at timestamp (seconds since epoch)
    uint64 executed_at = 7;
    // Optional event id that originated this transfer
    optional string event_id = 8;
}

// A request to retrieve token transfers
message TokenTransferQuery {
    // Filter by any of these account addresses (as sender or recipient)
    repeated bytes account_addresses = 1;
    // Filter by token contract addresses
    repeated bytes contract_addresses = 2;
    // Filter by token IDs (bytes of numeric id)
    repeated bytes token_ids = 3;
    // Pagination
    Pagination pagination = 4;
}

enum CallType {
    EXECUTE = 0;
    EXECUTE_FROM_OUTSIDE = 1;
}

message TransactionCall {
    // The contract address being called
    bytes contract_address = 1;
    // The function name being called
    string entrypoint = 2;
    // The calldata for the function call
    repeated bytes calldata = 3;
    // The type of call (EXECUTE, EXECUTE_FROM_OUTSIDE)
    CallType call_type = 4;
    // The address making the call
    bytes caller_address = 5;
}

message Transaction {
    // The transaction hash
    bytes transaction_hash = 1;
    // The sender address
    bytes sender_address = 2;
    // The transaction calldata
    repeated bytes calldata = 3;
    // The maximum fee for the transaction
    bytes max_fee = 4;
    // The transaction signature
    repeated bytes signature = 5;
    // The transaction nonce
    bytes nonce = 6;
    // The block number the transaction was included in
    uint64 block_number = 7;
    // The transaction type (INVOKE, L1_HANDLER, etc.)
    string transaction_type = 8;
    // The timestamp when the transaction was executed
    uint64 block_timestamp = 9;
    // The parsed calls within the transaction
    repeated TransactionCall calls = 10;
    // The unique models associated with this transaction
    repeated bytes unique_models = 11;
}

message TransactionFilter {
    // The list of transaction hashes to retrieve
    repeated bytes transaction_hashes = 1;
    // The list of caller addresses to filter by
    repeated bytes caller_addresses = 2;
    // The list of contract addresses to filter by (calls made to these contracts)
    repeated bytes contract_addresses = 3;
    // The list of entrypoints to filter by
    repeated string entrypoints = 4;
    // The list of model selectors to filter by
    repeated bytes model_selectors = 5;
    // The block number range to filter by
    optional uint64 from_block = 6;
    optional uint64 to_block = 7;
}

message TransactionQuery {
    // The filter to apply to the query
    TransactionFilter filter = 1;
    // Pagination
    Pagination pagination = 2;
}

// Activity tracking for user sessions
message Activity {
    // Unique identifier: world_address:namespace:caller_address:session_start_timestamp
    string id = 1;
    // World contract address
    bytes world_address = 2;
    // Namespace
    string namespace = 3;
    // Caller address
    bytes caller_address = 4;
    // Session start time
    uint64 session_start = 5;
    // Session end time
    uint64 session_end = 6;
    // Total action count in session
    uint32 action_count = 7;
    // Map of action names to call counts
    map<string, uint32> actions = 8;
    // Last update timestamp
    uint64 updated_at = 9;
}

message ActivityQuery {
    // Filter by world addresses
    repeated bytes world_addresses = 1;
    // Filter by namespaces
    repeated string namespaces = 2;
    // Filter by caller addresses
    repeated bytes caller_addresses = 3;
    // Filter by time range (unix timestamps)
    optional uint64 from_time = 4;
    optional uint64 to_time = 5;
    // Pagination
    Pagination pagination = 6;
}

enum ContractType {
    WORLD = 0;
    ERC20 = 1;
    ERC721 = 2;
    ERC1155 = 3;
    UDC = 4;
    OTHER = 5;
}

// SQL query value types
message SqlValue {
    oneof value_type {
        string text = 1;
        int64 integer = 2;
        double real = 3;
        bytes blob = 4;
        bool null = 5;
    }
}

// A single row from SQL query results
message SqlRow {
    // Map of column name to value
    map<string, SqlValue> fields = 1;
}

// A request to execute a SQL query
message SqlQueryRequest {
    // The SQL query to execute
    string query = 1;
}

// A response containing SQL query results
message SqlQueryResponse {
    // The rows returned by the query
    repeated SqlRow rows = 1;
}

message Contract {
    // The contract address
    bytes contract_address = 1;
    // The type of contract
    ContractType contract_type = 2;
    // Current block height
    optional uint64 head = 3;
    // Transactions per second
    optional uint64 tps = 4;
    // Last block timestamp
    optional uint64 last_block_timestamp = 5;
    // Last pending block transaction
    optional bytes last_pending_block_tx = 6;
    // When the contract was last updated
    uint64 updated_at = 7;
    // When the contract was first tracked
    uint64 created_at = 8;
}

// A request to retrieve contracts
message ContractQuery {
    // The list of contract addresses to retrieve
    repeated bytes contract_addresses = 1;
    // The list of contract types to filter by
    repeated ContractType contract_types = 2;
}

message TokenContract {
    // The contract address
    bytes contract_address = 1;
    // The type of contract
    ContractType contract_type = 2;
    // The name of the contract
    string name = 3;
    // The symbol of the contract
    string symbol = 4;
    // The decimals of the contract
    uint32 decimals = 5;
    // The metadata of the contract
    bytes metadata = 6;
    // The total supply of the contract
    optional bytes total_supply = 7;
    // The traits of the contract (JSON object with trait types and possible values)
    string traits = 8;
    // The first token metadata of the contract
    bytes token_metadata = 9;
}

// A query for aggregations (leaderboards, stats, rankings)
message AggregationQuery {
    // The list of aggregator IDs to retrieve (e.g., "top_scores", "most_wins")
    repeated string aggregator_ids = 1;
    // The list of entity IDs to filter by (optional)
    repeated string entity_ids = 2;
    // Pagination
    Pagination pagination = 3;
}

// An entry in an aggregation with its calculated position
message AggregationEntry {
    // Unique identifier for this entry
    string id = 1;
    // The aggregator this entry belongs to
    string aggregator_id = 2;
    // The entity being ranked
    string entity_id = 3;
    // Normalized value for ordering (zero-padded hex)
    bytes value = 4;
    // Display value for presentation (original format)
    string display_value = 5;
    // Calculated position/rank (1-indexed)
    uint64 position = 6;
    // The model ID this aggregation is based on
    string model_id = 7;
    // When the entry was created (RFC3339 timestamp)
    string created_at = 8;
    // When the entry was last updated (RFC3339 timestamp)
    string updated_at = 9;
}

// Achievement definition
message Achievement {
    // Achievement ID (unique identifier)
    string id = 1;
    // World contract address
    bytes world_address = 2;
    // Namespace
    string namespace = 3;
    // Entity ID from on-chain
    string entity_id = 4;
    // Is this achievement hidden
    bool hidden = 5;
    // Display index/order
    uint32 index = 6;
    // Points awarded for completion
    uint32 points = 7;
    // Start time
    string start = 8;
    // End time
    string end = 9;
    // Achievement group
    string group = 10;
    // Icon identifier
    string icon = 11;
    // Achievement title
    string title = 12;
    // Achievement description
    string description = 13;
    // Tasks to complete for this achievement
    repeated AchievementTask tasks = 14;
    // Additional data (JSON)
    optional string data = 15;
    // Total completions across all players
    uint32 total_completions = 16;
    // Completion rate (percentage 0-100)
    double completion_rate = 17;
    // When the achievement was created
    uint64 created_at = 18;
    // When the achievement was last updated
    uint64 updated_at = 19;
}

// A task within an achievement
message AchievementTask {
    // Task ID from on-chain (unique within achievement)
    string task_id = 1;
    // Task description
    string description = 2;
    // Target count to complete this task
    uint32 total = 3;
    // Total completions across all players
    uint32 total_completions = 4;
    // Completion rate (percentage 0-100)
    double completion_rate = 5;
    // When the task was created
    uint64 created_at = 6;
}

// Player's global achievement statistics (across all worlds/namespaces)
message PlayerAchievementStats {
    // Total points earned across all games
    uint32 total_points = 1;
    // Number of achievements completed across all games
    uint32 completed_achievements = 2;
    // Total achievements available across all games
    uint32 total_achievements = 3;
    // Overall completion percentage
    double completion_percentage = 4;
    // Last achievement completion time (across all games)
    optional uint64 last_achievement_at = 5;
    // When the stats were first created
    uint64 created_at = 6;
    // When the stats were last updated
    uint64 updated_at = 7;
}

// Achievement progression for a specific player and task
message AchievementProgression {
    // Unique identifier (world:namespace:task_id:player_id)
    string id = 1;
    // Achievement ID this task belongs to
    string achievement_id = 2;
    // Task ID
    string task_id = 3;
    // World address
    bytes world_address = 4;
    // Namespace
    string namespace = 5;
    // Player address
    bytes player_id = 6;
    // Current count/progress
    uint32 count = 7;
    // Is the task completed
    bool completed = 8;
    // When the task was completed
    optional uint64 completed_at = 9;
    // When the progression was created
    uint64 created_at = 10;
    // When the progression was last updated
    uint64 updated_at = 11;
}

// Query for achievements
message AchievementQuery {
    // Filter by world addresses
    repeated bytes world_addresses = 1;
    // Filter by namespaces
    repeated string namespaces = 2;
    // Filter by hidden status (optional)
    optional bool hidden = 3;
    // Pagination
    Pagination pagination = 4;
}

// Query for player achievements
message PlayerAchievementQuery {
    // Filter by world addresses
    repeated bytes world_addresses = 1;
    // Filter by namespaces
    repeated string namespaces = 2;
    // Filter by player addresses
    repeated bytes player_addresses = 3;
    // Pagination
    Pagination pagination = 4;
}

// Player's progress on a specific achievement
message PlayerAchievementProgress {
    // The achievement definition (includes task definitions)
    Achievement achievement = 1;
    // Progress on each task (references tasks by ID)
    repeated TaskProgress taskProgress = 2;
    // Is the achievement completed
    bool completed = 3;
    // Progress percentage (0-100)
    double progress_percentage = 4;
}

// Progress on a specific task (reference only, no duplication)
message TaskProgress {
    // Task ID reference (matches task_id in Achievement.tasks)
    string task_id = 1;
    // Current count
    uint32 count = 2;
    // Is the task completed
    bool completed = 3;
}

// Player achievement entry (for a specific world/namespace/player combination)
message PlayerAchievementEntry {
    // Player address (global identifier)
    bytes player_address = 1;
    // Player's overall statistics (across all worlds/namespaces)
    PlayerAchievementStats stats = 2;
    // Progress on each achievement (each achievement has its own world/namespace scope)
    repeated PlayerAchievementProgress achievements = 3;
}

// Player achievement data (list of player entries)
